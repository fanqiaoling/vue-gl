(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):(e=e||self,t(e.VueGL={},e.THREE))})(this,function(e,t){'use strict';var w=Math.PI;function i(e,t){return i=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},i(e,t)}function r(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],function(){})),!0}catch(t){return!1}}function n(){return n=r()?Reflect.construct:function(e,t,r){var n=[null];n.push.apply(n,t);var a=Function.bind.apply(e,n),s=new a;return r&&i(s,r.prototype),s},n.apply(null,arguments)}function s(e,t){return p(e)||c(e,t)||u()}function o(e){return l(e)||d(e)||m()}function l(e){if(Array.isArray(e)){for(var t=0,a=Array(e.length);t<e.length;t++)a[t]=e[t];return a}}function p(e){if(Array.isArray(e))return e}function d(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}function c(e,t){var a=[],i=!0,r=!1,n=void 0;try{for(var s,o=e[Symbol.iterator]();!(i=(s=o.next()).done)&&(a.push(s.value),!(t&&a.length===t));i=!0);}catch(e){r=!0,n=e}finally{try{i||null==o["return"]||o["return"]()}finally{if(r)throw n}}return a}function m(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function u(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}/**
   * Returns a parsed quaternion object.
   */function g(e){return e.isQuaternion?e:n(t.Quaternion,o(e.trim().split(/\s+/).map(function(e){return parseFloat(e)})))}/**
   * Returns a parsed vector3 object.
   */function h(e){return e.isVector3?e:n(t.Vector3,o(e.trim().split(/\s+/).map(function(e){return parseFloat(e)})))}/**
   * Returns a parsed vector2 object.
   */function f(e){return e.isVector2?e:n(t.Vector2,o(e.trim().split(/\s+/).map(function(e){return parseFloat(e)})))}/**
   * Returns a parsed euler object.
   */function y(e){return e.isEuler?e:n(t.Euler,o(e.trim().split(/\s+/).map(function(e,t){return 3===t?e:parseFloat(e)})))}/**
   * Returns a parsed spherical object.
   */function b(e){return e.isSpherical?e:n(t.Spherical,o(e.trim().split(/\s+/).map(function(e){return parseFloat(e)}))).makeSafe()}/**
   * Returns a parsed array.
   */function v(e){return Array.isArray(e)?e:e.split(",")}/**
   * Returns a parsed array of vector2.
   */function S(e){return v(e).map(function(e){return f(e)})}/**
   * Returns a parsed fog object
   */function x(e){return e.isFog?e:n(t.Fog,o(e.trim().split(/\s+/).map(function(e,t){return 0===t?e:parseFloat(e)})))}/**
   * Returns a parsed Color object
   */function N(e){return e.isColor?e:new t.Color(e)}var M={inject:{vglNamespace:{default:function(){var e,t=this,a=[],i=[];return{renderers:a,cameras:Object.create(null),scenes:Object.create(null),update:function(){e||(t.$nextTick(function(){i.forEach(function(e){e()}),a.forEach(function(e){e.render()}),e=!1}),e=!0)},beforeRender:i,geometries:Object.create(null),materials:Object.create(null),textures:Object.create(null),object3ds:Object.create(null)}}}},provide:function(){return{vglNamespace:Object.create(this.vglNamespace,{geometries:{value:Object.create(this.vglNamespace.geometries)},materials:{value:Object.create(this.vglNamespace.materials)},textures:{value:Object.create(this.vglNamespace.textures)},object3ds:{value:Object.create(this.vglNamespace.object3ds)}})}},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},V=[String,Number],L=String,A=[String,t.Vector3],C=[String,t.Spherical],R=Boolean,G=[String,t.Euler],T=[String,t.Vector2],B=[String,t.Quaternion],j=[String,Array],z=[String,Array],D=[String,t.Fog],P=[String,Array],H={props:{/** The object's local position as a 3D vector. */position:A,/** The object's local rotation as a euler angle. */rotation:G,/**
       * The object's local rotation as a quaternion (specified in x, y, z, w order).
       * Do not use in conjunction with the rotation prop, since they both control the same property
       * of the underlying THREE.Object3D object.
       */rotationQuaternion:B,/** The object's local scale as a 3D vector. */scale:A,/** Whether the object gets rendered into shadow map. */castShadow:R,/** Whether the material receives shadows. */receiveShadow:R,/** Optional name of the object. */name:L,/** Whether the object is visible. */visible:{type:R,default:!0}},computed:{inst:function(){return new t.Object3D}},inject:{vglObject3d:{default:{}},vglNamespace:"vglNamespace"},provide:function(){var e=this;return{vglObject3d:{get inst(){return e.inst}}}},created:function(){this.vglNamespace.update()},beforeUpdate:function(){this.vglNamespace.update()},beforeDestroy:function(){var e=this.vglNamespace,t=this.inst,a=this.name;t.parent&&t.parent.remove(t),e.object3ds[a]===t&&delete e.object3ds[a],e.update()},watch:{inst:{handler:function(e,t){t&&t.parent&&t.parent.remove(t),this.vglObject3d.inst&&this.vglObject3d.inst.add(e),this.position&&e.position.copy(h(this.position)),this.rotation&&e.rotation.copy(y(this.rotation)),this.rotationQuaternion&&e.quaternion.copy(g(this.rotationQuaternion)),this.scale&&e.scale.copy(h(this.scale)),Object.assign(e,{castShadow:this.castShadow,receiveShadow:this.receiveShadow,visible:this.visible}),this.name!==void 0&&(e.name=this.name,this.vglNamespace.object3ds[this.name]=e)},immediate:!0},"vglObject3d.inst":function(e){e.add(this.inst)},position:function(e){this.inst.position.copy(h(e))},rotation:function(e){this.inst.rotation.copy(y(e))},rotationQuaternion:function(e){this.inst.quaternion.copy(g(e))},scale:function(e){this.inst.scale.copy(h(e))},castShadow:function(e){this.inst.castShadow=e},receiveShadow:function(e){this.inst.receiveShadow=e},name:function(e,t){var a=this.vglNamespace.object3ds,i=this.inst;a[t]===i&&delete a[t],this.inst.name=e,a[e]=i},visible:function(e){this.inst.visible=e}},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},F={mixins:[H],props:{/**
       * Position in 3D space for the camera to point towards.
       * This property overwrite rotation property when both defined.
       */orbitTarget:A,/**
       * Spherical position around orbitTarget.
       * This property overwrite position and rotation properties.
       * If orbitTarget is not defined, automatically set to (0, 0, 0).
       */orbitPosition:C},computed:{inst:function(){return new t.Camera}},watch:{inst:{handler:function(e){if(this.vglNamespace.cameras[this.name]=e,this.orbitPosition||this.orbitTarget){var a;this.orbitTarget&&(a=h(this.orbitTarget)),this.orbitPosition&&(e.position.setFromSpherical(b(this.orbitPosition)),a&&e.position.add(a)),e.lookAt(a||new t.Vector3)}},immediate:!0},name:function(e,t){var a=this.vglNamespace.cameras,i=this.inst;a[t]===i&&delete a[t],a[e]=i},orbitTarget:function(e){var t=h(e);this.orbitPosition&&this.inst.position.setFromSpherical(b(this.orbitPosition)).add(t),this.inst.lookAt(t)},orbitPosition:function(e){if(this.inst.position.setFromSpherical(b(e)),this.orbitTarget){var a=h(this.orbitTarget);this.inst.position.add(a),this.inst.lookAt(a)}else this.inst.lookAt(new t.Vector3)}},beforeDestroy:function(){var e=this.vglNamespace.cameras,t=this.inst;e[this.name]===t&&delete e[this.name]}},k={mixins:[H],props:{/** CSS style color of the light. */color:{type:L,default:"#fff"},/** Numeric value of the light's strength/intensity. */intensity:{type:V,default:1}},computed:{inst:function(){return new t.Light}},watch:{inst:{handler:function(e){e.color.setStyle(this.color),Object.assign(e,{intensity:parseFloat(this.intensity)})},immediate:!0},color:function(e){this.inst.color.setStyle(e)},intensity:function(e){this.inst.intensity=parseFloat(e)}}},E={no:t.NoColors,vertex:t.VertexColors,face:t.FaceColors},O={front:t.FrontSide,back:t.BackSide,double:t.DoubleSide},$={inject:["vglNamespace"],props:{/** Name of the material. */name:L,/** Defines which side of faces will be rendered. front, back or double. */side:{type:L,default:"front"},/** Defines whether vertex coloring is used. Other options are 'vertex' and 'face'. */vertexColors:{type:L,default:"no"}},computed:{inst:function(){return new t.Material}},watch:{inst:{handler:function(e){e.setValues({side:O[this.side],vertexColors:E[this.vertexColors]}),this.vglNamespace.materials[this.name]=e},immediate:!0},name:function(e,t){var a=this.vglNamespace.materials,i=this.inst;a[t]===i&&delete a[t],a[e]=i},side:function(e){this.inst.side=O[e]},vertexColors:function(e){this.inst.vertexColors=E[e]}},beforeDestroy:function(){var e=this.vglNamespace.materials,t=this.inst;e[this.name]===t&&delete e[this.name]},created:function(){this.vglNamespace.update()},beforeUpdate:function(){this.vglNamespace.update()},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},U={inject:["vglNamespace"],props:{/** Name of the component. */name:L,/** The x, y, and z coordinates of each vertex in this geometry. */positionAttribute:j,/** The red, green, and blue channels of vertex color of each vertex in this geometry. */colorAttribute:j,/** The x, y, and z components of the vertex normal vector of each vertex in this geometry. */normalAttribute:j},computed:{inst:function(){return new t.BufferGeometry}},watch:{inst:{handler:function(e,a){if(this.positionAttribute){var i=a?a.getAttribute("position"):new t.BufferAttribute(new Float32Array(v(this.positionAttribute)),3);e.addAttribute("position",i)}if(this.colorAttribute){var r=a?a.getAttribute("color"):new t.BufferAttribute(new Float32Array(v(this.colorAttribute)),3);e.addAttribute("color",r)}if(this.normalAttribute){var n=a?a.getAttribute("normal"):new t.BufferAttribute(new Float32Array(v(this.normalAttribute)),3);e.addAttribute("normal",n)}a&&a.dispose(),this.vglNamespace.geometries[this.name]=e},immediate:!0},name:function(e,t){var a=this.vglNamespace.geometries,i=this.inst;a[t]===i&&delete a[t],a[e]=i},positionAttribute:function(e){var t=v(e),a=this.inst.getAttribute("position");a.array.length===t.length?a.copyArray(t):a.setArray(new Float32Array(t)),a.needsUpdate=!0},colorAttribute:function(e){var t=v(e),a=this.inst.getAttribute("color");a.array.length===t.length?a.copyArray(t):a.setArray(new Float32Array(t)),a.needsUpdate=!0},normalAttribute:function(e){var t=v(e),a=this.inst.getAttribute("normal");a.array.length===t.length?a.copyArray(t):a.setArray(new Float32Array(t)),a.needsUpdate=!0}},beforeDestroy:function(){var e=this.vglNamespace.geometries,t=this.inst;e[this.name]===t&&delete e[this.name],t.dispose()},created:function(){this.vglNamespace.update()},beforeUpdate:function(){this.vglNamespace.update()},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},W={mixins:[H],methods:{setMaterial:function(){var e=this.vglNamespace.materials,t=this.material,a=this.inst;Array.isArray(t)?a.material=t.reduce(function(t,a){return e[a]?[].concat(o(t),[e[a]]):t},[]):e[t]&&(a.material=e[t])}},created:function(){this.vglNamespace.beforeRender.unshift(this.setMaterial)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setMaterial;e.splice(e.indexOf(t),1)}},_={mixins:[W],methods:{setGeometry:function(){var e=this.vglNamespace.geometries,t=this.geometry,a=this.inst;e[t]&&(a.geometry=e[t])}},created:function(){this.vglNamespace.beforeRender.unshift(this.setGeometry)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setGeometry;e.splice(e.indexOf(t),1)}},I={mixins:[$],methods:{setMap:function(){var e=this.vglNamespace.textures,t=this.inst,a=this.map;a in e&&(t.map=e[a])}},created:function(){this.vglNamespace.beforeRender.unshift(this.setMap)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setMap;e.splice(e.indexOf(t),1)}},q={mixins:[I],props:{/** CSS style color of the material. */color:{type:L,default:"#fff"},/** The color map of the material. */map:L},computed:{inst:function(){return new t.MeshStandardMaterial}},watch:{inst:{handler:function(e){e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)}}},Q={mixins:[_],props:{/** Name of the geometry, representing the line segment(s). */geometry:L,/** Name of the material for the line. */material:L},computed:{inst:function(){return new t.Line}},methods:{computeLineDistances:function(){this.inst.material.isLineDashedMaterial&&this.inst.computeLineDistances()}},created:function(){this.vglNamespace.beforeRender.push(this.computeLineDistances)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.computeLineDistances;e.splice(e.indexOf(t),1)}},K={mixins:[U],props:{/** Radius of the cylinder at the top. */radiusTop:{type:V,default:1},/** Radius of the cylinder at the bottom. */radiusBottom:{type:V,default:1},/** Height of the cylinder. */height:{type:V,default:1},/** Number of segmented faces around the circumference of the cylinder. */radialSegments:{type:V,default:8},/** Number of rows of faces along the height of the cylinder. */heightSegments:{type:V,default:1},/** A Boolean indicating whether the ends of the cylinder are open or capped. */openEnded:R,/** Start angle for first segment. */thetaStart:{type:V,default:0},/** The central angle of the circular sector. */thetaLength:{type:V,default:2*w}},computed:{inst:function(){return new t.CylinderBufferGeometry(parseFloat(this.radiusTop),parseFloat(this.radiusBottom),parseFloat(this.height),parseInt(this.radialSegments,10),parseInt(this.heightSegments,10),this.openEnded,parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},J={uv:t.UVMapping,"cube-reflection":t.CubeReflectionMapping,"cube-refraction":t.CubeRefractionMapping,"equirectangular-reflection":t.EquirectangularReflectionMapping,"equirectangular-refraction":t.EquirectangularRefractionMapping,"spherical-reflection":t.SphericalReflectionMapping,"cube-uv-reflection":t.CubeUVReflectionMapping,"cube-uv-refraction":t.CubeUVRefractionMapping},X={repeat:t.RepeatWrapping,"clamp-to-edge":t.ClampToEdgeWrapping,"mirrored-repeat":t.MirroredRepeatWrapping},Y={nearest:t.NearestFilter,"nearest-mip-map-nearest":t.NearestMipMapNearestFilter,"nearest-mip-map-linear":t.NearestMipMapLinearFilter,linear:t.LinearFilter,"linear-mip-map-nearest":t.LinearMipMapNearestFilter,"linear-mip-map-linear":t.LinearMipMapLinearFilter},Z={alpha:t.AlphaFormat,rgb:t.RGBFormat,rgba:t.RGBAFormat,luminance:t.LuminanceFormat,"luminance-alpha":t.LuminanceAlphaFormat,rgbe:t.RGBEFormat,depth:t.DepthFormat,"depth-stencil":t.DepthStencilFormat},ee={"unsigned-byte":t.UnsignedByteType,byte:t.ByteType,short:t.ShortType,"unsigned-short":t.UnsignedShortType,int:t.IntType,"unsigned-int":t.UnsignedIntType,float:t.FloatType,"half-float":t.HalfFloatType,"unsigned-short-4444":t.UnsignedShort4444Type,"unsigned-short-5551":t.UnsignedShort5551Type,"unsigned-short-565":t.UnsignedShort565Type,"unsigned-int-248":t.UnsignedInt248Type},te={linear:t.LinearEncoding,"s-rgb":t.sRGBEncoding,gamma:t.GammaEncoding,rgbe:t.RGBEEncoding,"log-luv":t.LogLuvEncoding,rgbm7:t.RGBM7Encoding,rgbm16:t.RGBM16Encoding,rgbde:t.RGBDEncoding,"basic-depth":t.BasicDepthPacking,"rgba-depth":t.RGBADepthPacking},ae={mixins:[U],computed:{inst:function(){return new t.ExtrudeBufferGeometry([],{})}}},ie=Object.create(null),re={mixins:[I],props:{/** CSS style color of the material. */color:{type:L,default:"#fff"},/** The color map of the material. */map:L,/** Specular color of the material. */specular:{type:L,default:"#111111"},/** How shiny the specular highlight is. A higher value gives a sharper highlight. */shininess:{type:V,default:30}},computed:{inst:function(){return new t.MeshPhongMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{shininess:parseFloat(this.shininess)}),e.specular.setStyle(this.specular),e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)},specular:function(e){this.inst.specular.setStyle(e)},shininess:function(e){this.inst.shininess=parseFloat(e)}}};e.VglAmbientLight={mixins:[k],computed:{inst:function(){return new t.AmbientLight}}},e.VglArrowHelper={mixins:[H],props:{/** Direction from origin. */dir:A,/** Length of the arrow. */length:{type:V,default:1},/** Color of the arrow. */color:{type:L,default:"#ff0"},/** The length of the head of the arrow. */headLength:V,/** The width of the head of the arrow. */headWidth:V},computed:{inst:function(){return new t.ArrowHelper(new t.Vector3(0,1,0),new t.Vector3())},len:function(){return[parseFloat(this.length),this.headLength===void 0?void 0:parseFloat(this.headLength),this.headWidth===void 0?void 0:parseFloat(this.headWidth)]}},watch:{inst:{handler:function(e){this.dir&&e.setDirection(h(this.dir).normalize()),e.setLength.apply(e,o(this.len)),e.setColor(new t.Color(this.color))},immediate:!0},dir:function(e){this.inst.setDirection(h(e).normalize())},len:function(e){var t;(t=this.inst).setLength.apply(t,o(e))},color:function(e){this.inst.setColor(new t.Color(e))}}},e.VglAxesHelper={mixins:[H],props:{/** Size of the lines representing the axes. */size:{type:V,default:1}},computed:{inst:function(){return new t.AxesHelper(parseFloat(this.size))}}},e.VglBoxGeometry={mixins:[U],props:{/** Width of the sides on the X axis. */width:{type:V,default:1},/** Height of the sides on the Y axis. */height:{type:V,default:1},/** Depth of the sides on the Z axis. */depth:{type:V,default:1},/** Number of segmented faces along the width of the sides. */widthSegments:{type:V,default:1},/** Number of segmented faces along the height of the sides. */heightSegments:{type:V,default:1},/** Number of segmented faces along the depth of the sides. */depthSegments:{type:V,default:1}},computed:{inst:function(){return new t.BoxBufferGeometry(parseFloat(this.width),parseFloat(this.height),parseFloat(this.depth),parseInt(this.widthSegments,10),parseInt(this.heightSegments,10),parseInt(this.depthSegments,10))}}},e.VglBoxHelper={mixins:[H],props:{/** Size of the lines representing the axes. */color:{type:L,default:"#ff0"},/** Name of the object to show the world-axis-aligned boundingbox. */object:L},computed:{inst:function(){return new t.BoxHelper(void 0,this.color)}},methods:{setFromObject:function(){this.inst.setFromObject(this.vglNamespace.object3ds[this.object])}},created:function(){this.vglNamespace.beforeRender.push(this.setFromObject)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setFromObject;e.splice(e.indexOf(t),1)}},e.VglCamera=F,e.VglCameraHelper={mixins:[H],props:{/** Name of the camera to visualize. */camera:L},methods:{setHelper:function(){if(!this.inst.children.length)this.inst.add(new t.CameraHelper(this.vglNamespace.cameras[this.camera]));else{var e=s(this.inst.children,1),a=e[0];a.camera=this.vglNamespace.cameras[this.camera],a.camera.updateProjectionMatrix(),a.update()}}},created:function(){this.vglNamespace.beforeRender.push(this.setHelper)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setHelper;e.splice(e.indexOf(t),1)}},e.VglCircleGeometry={mixins:[U],props:{/** Radius of the circle. */radius:{type:V,default:1},/** Number of segments (triangles). */segments:{type:V,default:8},/** Start angle for first segment. */thetaStart:{type:V,default:0},/** The central angle of the circular sector. */thetaLength:{type:V,default:2*w}},computed:{inst:function(){return new t.CircleBufferGeometry(parseFloat(this.radius),parseInt(this.segments,10),parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},e.VglConeGeometry={mixins:[K],props:{/** Radius of the cone at the base. */radius:{type:V,default:1}},computed:{inst:function(){return new t.ConeBufferGeometry(parseFloat(this.radius),parseFloat(this.height),parseInt(this.radialSegments,10),parseInt(this.heightSegments,10),this.openEnded,parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},e.VglCylinderGeometry=K,e.VglDirectionalLight={mixins:[k],computed:{inst:function(){return new t.DirectionalLight}}},e.VglDirectionalLightHelper={mixins:[H],props:{/** If this is not the set the helper will take the color of the light. */color:{type:L},/** Dimensions of the plane. */size:{type:V,default:1},/** Name of the directional light being visualized. */light:L},data:function(){return{s:void 0}},methods:{setHelper:function(){var e=this.vglNamespace.object3ds[this.light];if(this.inst.children.length){var a=s(this.inst.children,1),i=a[0];if(i.light===e&&this.s===this.size)return i.color=this.color,void i.update();this.inst.remove(i)}this.s=this.size,this.inst.add(new t.DirectionalLightHelper(e,parseFloat(this.size),this.color))}},created:function(){this.vglNamespace.beforeRender.push(this.setHelper)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setHelper;e.splice(e.indexOf(t),1)}},e.VglDodecahedronGeometry={mixins:[U],props:{/** Radius of the dodecahedron. */radius:{type:V,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a dodecahedron. */detail:{type:V,default:0}},computed:{inst:function(){return new t.DodecahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},e.VglExtrudeGeometry=ae,e.VglGeometry=U,e.VglGridHelper={mixins:[H],props:{/** The size of the grid. */size:{type:V,default:10},/** The number of divisions across the grid. */divisions:{type:V,default:10},/** The color of the centerline. */colorCenterLine:{type:L,default:"#444444"},/** The color of the lines of the grid. */colorGrid:{type:L,default:"#888888"}},computed:{inst:function(){return new t.GridHelper(parseFloat(this.size),parseInt(this.divisions,10),this.colorCenterLine,this.colorGrid)}}},e.VglGroup={mixins:[H],computed:{inst:function(){return new t.Group}}},e.VglHemisphereLight={mixins:[k],props:{groundColor:{type:L,default:"#fff"}},computed:{inst:function(){return new t.HemisphereLight}},watch:{inst:{handler:function(e){e.groundColor.setStyle(this.groundColor)},immediate:!0},groundColor:function(e){this.inst.groundColor.setStyle(e)}}},e.VglIcosahedronGeometry={mixins:[U],props:{/** Radius of the icosahedron. */radius:{type:V,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a icosahedron. */detail:{type:V,default:0}},computed:{inst:function(){return new t.IcosahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},e.VglLatheGeometry={mixins:[U],props:{/** Array of Vector2s. The x-coordinate of each point must be greater than zero. */points:{type:z,required:!0},/** The number of circumference segments to generate. */segments:{type:V,default:12},/** The starting angle in radians. */phiStart:{type:V,default:0},/** The radian (0 to 2PI) range of the lathed section. */phiLength:{type:V,default:2*w}},computed:{inst:function(){return new t.LatheBufferGeometry(S(this.points),parseInt(this.segments,10),parseFloat(this.phiStart),parseFloat(this.phiLength))}}},e.VglLight=k,e.VglLine=Q,e.VglLineBasicMaterial={mixins:[$],props:{/** CSS style color of the material. */color:{type:L,default:"#fff"},/** A boolean whether the material is affected by lights. */lights:R,/** The line thickness. */linewidth:{type:V,default:1},/** Define appearance of line ends. Possible values are "butt", "round" and "square". */linecap:{type:L,default:"round"},/** Define appearance of line joints. Possible values are "round", "bevel" and "miter". */linejoin:{type:L,default:"round"}},computed:{inst:function(){return new t.LineBasicMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{lights:this.lights,linecap:this.linecap,linejoin:this.linejoin,linewidth:parseFloat(this.linewidth)}),e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)},lights:function(e){this.inst.lights=e},linewidth:function(e){this.inst.linewidth=parseFloat(e)},linecap:function(e){this.inst.linecap=e},linejoin:function(e){this.inst.linejoin=e}}},e.VglLineDashedMaterial={mixins:[$],props:{/** CSS style color of the material. */color:{type:L,default:"#fff"},/** A boolean whether the material is affected by lights. */lights:R,/** The line thickness. */linewidth:{type:V,default:1},/** The size of the dash. This is both the gap with the stroke. */dashSize:{type:V,default:3},/** The size of the gap. */gapSize:{type:V,default:1}},computed:{inst:function(){return new t.LineDashedMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{lights:this.lights,dashSize:parseFloat(this.dashSize),gapSize:parseFloat(this.gapSize),linewidth:parseFloat(this.linewidth)}),e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)},lights:function(e){this.inst.lights=e},linewidth:function(e){this.inst.linewidth=parseFloat(e)},dashSize:function(e){this.inst.dashSize=parseFloat(e)},gapSize:function(e){this.inst.gapSize=parseFloat(e)}}},e.VglLineLoop={mixins:[Q],computed:{inst:function(){return new t.LineLoop}}},e.VglLineSegments={mixins:[Q],computed:{inst:function(){return new t.LineSegments}}},e.VglMaterial=$,e.VglMesh={mixins:[_],props:{/** Name of the geometry, defining the object's structure. */geometry:L,/**
       * A Material name or an array of Material name, defining the object's appearance.
       *
       * A single material will apply the material to all object's faces meanwhile
       * an array of material will apply each material to the matching index object's face
       */material:P},computed:{inst:function(){return new t.Mesh}}},e.VglMeshBasicMaterial={mixins:[I],props:{/** CSS style color of the material. */color:{type:L,default:"#fff"},/** The color map of the material. */map:L},computed:{inst:function(){return new t.MeshBasicMaterial}},watch:{inst:{handler:function(e){e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)}}},e.VglMeshDepthMaterial={mixins:[I],props:{/** Whether the material is affected by fog. */fog:R,/** The color map of the material. */map:L},computed:{inst:function(){return new t.MeshDepthMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{fog:this.fog})},immediate:!0},fog:function(e){this.inst.fog=e}}},e.VglMeshLambertMaterial={mixins:[I],props:{/** CSS style color of the material. */color:{type:L,default:"#fff"},/** The color map of the material. */map:L},computed:{inst:function(){return new t.MeshLambertMaterial}},watch:{inst:{handler:function(e){e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)}}},e.VglMeshNormalMaterial={mixins:[$],props:{/** Whether the material is affected by fog. */fog:R},computed:{inst:function(){return new t.MeshNormalMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{fog:this.fog})},immediate:!0},fog:function(e){this.inst.fog=e}}},e.VglMeshPhongMaterial=re,e.VglMeshPhysicalMaterial={mixins:[q],props:{/** ClearCoat level, from 0.0 to 1.0. */clearCoat:{type:V,default:0},/** How rough the clearCoat appears, from 0.0 to 1.0. */clearCoatRoughness:{type:V,default:0},/** Degree of reflectivity, from 0.0 to 1.0. */reflectivity:{type:V,default:.5}},computed:{inst:function(){return new t.MeshPhysicalMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{clearCoat:parseFloat(this.clearCoat),clearCoatRoughness:parseFloat(this.clearCoatRoughness),reflectivity:parseFloat(this.reflectivity)})},immediate:!0},clearCoat:function(e){this.inst.clearCoat=parseFloat(e)},clearCoatRoughness:function(e){this.inst.clearCoatRoughness=parseFloat(e)},reflectivity:function(e){this.inst.reflectivity=parseFloat(e)}}},e.VglMeshStandardMaterial=q,e.VglMeshToonMaterial={mixins:[re],computed:{inst:function(){return new t.MeshToonMaterial}}},e.VglNamespace=M,e.VglObject3d=H,e.VglOctahedronGeometry={mixins:[U],props:{/** Radius of the octahedron. */radius:{type:V,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a octahedron. */detail:{type:V,default:0}},computed:{inst:function(){return new t.OctahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},e.VglOrthographicCamera={mixins:[F],props:{/** Zoom factor of the camera. */zoom:{type:V,default:1},/** Camera frustum near plane. */near:{type:V,default:.1},/** Camera frustum far plane. */far:{type:V,default:2e3}},computed:{inst:function(){return new t.OrthographicCamera}},watch:{inst:{handler:function(e){Object.assign(e,{zoom:parseFloat(this.zoom),near:parseFloat(this.near),far:parseFloat(this.far)}),e.updateProjectionMatrix()},immediate:!0},zoom:function(e){this.inst.zoom=parseFloat(e),this.inst.updateProjectionMatrix()},near:function(e){this.inst.near=parseFloat(e),this.inst.updateProjectionMatrix()},far:function(e){this.inst.far=parseFloat(e),this.inst.updateProjectionMatrix()}}},e.VglPerspectiveCamera={mixins:[F],props:{/** Zoom factor of the camera. */zoom:{type:V,default:1},/** Camera frustum near plane. */near:{type:V,default:.1},/** Camera frustum far plane. */far:{type:V,default:2e3},/** Camera frustum vertical field of view, from bottom to top of view, in degrees. */fov:{type:V,default:50}},computed:{inst:function(){return new t.PerspectiveCamera}},watch:{inst:{handler:function(e){Object.assign(e,{zoom:parseFloat(this.zoom),near:parseFloat(this.near),far:parseFloat(this.far),fov:parseFloat(this.fov)}),e.updateProjectionMatrix()},immediate:!0},zoom:function(e){this.inst.zoom=parseFloat(e),this.inst.updateProjectionMatrix()},near:function(e){this.inst.near=parseFloat(e),this.inst.updateProjectionMatrix()},far:function(e){this.inst.far=parseFloat(e),this.inst.updateProjectionMatrix()},fov:function(e){this.inst.fov=parseFloat(e),this.inst.updateProjectionMatrix()}}},e.VglPlaneGeometry={mixins:[U],props:{/** Width along the X axis. */width:{type:V,default:1},/** Height along the Y axis. */height:{type:V,default:1},/** Number of segments along the X axis. */widthSegments:{type:V,default:1},/** Number of segments along the Y axis. */heightSegments:{type:V,default:1}},computed:{inst:function(){return new t.PlaneBufferGeometry(parseFloat(this.width),parseFloat(this.height),parseInt(this.widthSegments,10),parseInt(this.heightSegments,10))}}},e.VglPointLight={mixins:[k],props:{/**
       * The distance from the light where the intensity is 0.
       * When set to 0, then the light never stops.
       */distance:{type:V,default:0},/**
       * The amount the light dims along the distance of the light.
       * For physically correct lighting, set this to 2.
       */decay:{type:V,default:1}},computed:{inst:function(){return new t.PointLight}},watch:{inst:{handler:function(e){Object.assign(e,{distance:parseFloat(this.distance),decay:parseFloat(this.decay)})},immediate:!0},distance:function(e){this.inst.distance=parseFloat(e)},decay:function(e){this.inst.decay=parseFloat(e)}}},e.VglPoints={mixins:[_],props:{/** Name of the geometry, defining the object's structure. */geometry:L,/** Name of the material, defining the object's appearance. */material:L},computed:{inst:function(){return new t.Points}}},e.VglPointsMaterial={mixins:[$],props:{/** CSS style color of the material. */color:{type:L,default:"#fff"},/** The size of the points. */size:{type:V,default:1},/** Specify whether points' size will get smaller with the distance. */disableSizeAttenuation:R},computed:{inst:function(){return new t.PointsMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{size:parseFloat(this.size),sizeAttenuation:!this.disableSizeAttenuation}),e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)},size:function(e){this.inst.size=parseFloat(e)},disableSizeAttenuation:function(e){this.inst.sizeAttenuation=!e}}},e.VglPolarGridHelper={mixins:[H],props:{/** The radius of the polar grid. This can be any positive number. */radius:{type:V,default:10},/** The number of radial lines. This can be any positive integer. */radials:{type:V,default:16},/** The number of circles. This can be any positive integer. */circles:{type:V,default:8},/**
       * The number of line segments used for each circle.
       * This can be any positive integer that is 3 or greater.
       */divisions:{type:V,default:64},/** The first color used for grid elements. */color1:{type:L,default:"#444444"},/** The second color used for grid elements. */color2:{type:L,default:"#888888"}},computed:{inst:function(){return new t.PolarGridHelper(parseFloat(this.radius),parseInt(this.radials,10),parseInt(this.circles,10),parseInt(this.divisions,10),this.color1,this.color2)}}},e.VglRectAreaLight={mixins:[k],props:{/** Width of the light. */width:{type:V,default:10},/** Height of the light. */height:{type:V,default:10}},computed:{inst:function(){return new t.RectAreaLight}},watch:{inst:{handler:function(e){Object.assign(e,{width:parseFloat(this.width),height:parseFloat(this.height)})},immediate:!0},width:function(e){this.inst.width=parseFloat(e)},height:function(e){this.inst.height=parseFloat(e)}}},e.VglRectAreaLightHelper={mixins:[H],props:{/** If this is not the set the helper will take the color of the light. */color:{type:L},/** Name of the RectAreaLight being visualized. */light:{type:L,required:!0}},methods:{setHelper:function(){var e=this.vglNamespace.object3ds[this.light];if(this.inst.children.length){var a=s(this.inst.children,1),i=a[0];if(i.light===e)return i.color=this.color,void i.update();this.inst.remove(i)}this.inst.add(new t.RectAreaLightHelper(e,this.color))}},created:function(){this.vglNamespace.beforeRender.push(this.setHelper)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setHelper;e.splice(e.indexOf(t),1)}},e.VglRenderer={mixins:[M],props:{/** Shader precision. Can be "highp", "mediump" or "lowp". */precision:L,/** Whether the canvas contains an alpha (transparency) buffer or not. */alpha:R,/** Whether the renderer will assume that colors have premultiplied alpha. */disablePremultipliedAlpha:R,/** Whether to perform antialiasing. */antialias:R,/** Whether the drawing buffer has a stencil buffer of at least 8 bits. */disableStencil:R,/**
       * A hint to the user agent indicating what configuration of GPU is suitable
       * for this WebGL context. Can be "high-performance", "low-power" or "default".
       */powerPreference:L,/** Whether to preserve the buffers until manually cleared or overwritten. */preserveDrawingBuffer:R,/** Whether the drawing buffer has a depth buffer of at least 16 bits. */disableDepth:R,/** Whether to use a logarithmic depth buffer. */logarithmicDepthBuffer:R,/** Name of the using camera. */camera:L,/** Name of the target scene. */scene:L,/** If set, use shadow maps in the scene. */shadowMapEnabled:R},computed:{inst:function e(){var e=new t.WebGLRenderer({precision:this.precision,alpha:this.alpha,premultipliedAlpha:!this.disablePremultipliedAlpha,antialias:this.antialias,stencil:!this.disableStencil,preserveDrawingBuffer:this.preserveDrawingBuffer,depth:!this.disableDepth,logarithmicDepthBuffer:this.logarithmicDepthBuffer,powerPreference:this.powerPreference});return e.shadowMap.enabled=this.shadowMapEnabled,e},cameraInst:function(){if(this.camera!==void 0)return this.vglNamespace.cameras[this.camera];var e;// eslint-disable-next-line guard-for-in, no-restricted-syntax
for(var t in this.vglNamespace.cameras){if(e)throw new ReferenceError("Cannot identify the camera. camera prop must be set when multiple cameras are defined.");e=this.vglNamespace.cameras[t]}return e},sceneInst:function(){if(this.scene!==void 0)return this.vglNamespace.scenes[this.scene];var e;// eslint-disable-next-line guard-for-in, no-restricted-syntax
for(var t in this.vglNamespace.scenes){if(e)throw new ReferenceError("Cannot identify the scene. scene prop must be set when multiple scenes are defined.");e=this.vglNamespace.scenes[t]}return e}},methods:{render:function(){var e=this.inst,t=this.cameraInst,a=this.sceneInst;if(t&&a){if(t.isPerspectiveCamera){var i=this.$el.clientWidth/this.$el.clientHeight;t.aspect!==i&&(t.aspect=i,t.updateProjectionMatrix())}else if(t.isOrthographicCamera){var r=this.$el.clientWidth/2,n=this.$el.clientHeight/2;(t.right!==r||t.top!==n)&&(t.left=-r,t.right=r,t.top=n,t.bottom=-n,t.updateProjectionMatrix())}else throw new TypeError("Unknown camera type.");e.render(a,t)}}},watch:{inst:function(e,t){this.$el&&(e.setSize(this.$el.clientWidth,this.$el.clientHeight),this.$el.replaceChild(e.domElement,t.domElement),this.vglNamespace.update()),t.dispose()}},created:function(){this.vglNamespace.renderers.push(this)},mounted:function(){this.inst.setSize(this.$el.clientWidth,this.$el.clientHeight),this.$el.appendChild(this.inst.domElement),this.vglNamespace.update()},beforeDestroy:function(){this.vglNamespace.renderers.splice(this.vglNamespace.renderers.indexOf(this),1),this.inst.dispose()},render:function(e){var t=this;return e("div",[e("iframe",{style:{visibility:"hidden",width:"100%",height:"100%",marginRight:"-100%",border:"none"},on:{load:function(e){e.target.contentWindow.addEventListener("resize",function(){t.inst.setSize(t.$el.clientWidth,t.$el.clientHeight),t.vglNamespace.update()},!1)}}},this.$slots.default)])}},e.VglRingGeometry={mixins:[U],props:{/** Inner radius of the ring. */innerRadius:{type:V,default:.5},/** Outer radius of the ring. */outerRadius:{type:V,default:1},/** Number of segments along to the tangential direction. */thetaSegments:{type:V,default:8},/** Number of segments along to the radial direction. */phiSegments:{type:V,default:1},/** The starting angle. */thetaStart:{type:V,default:0},/** The central angle. */thetaLength:{type:V,default:2*w}},computed:{inst:function(){return new t.RingBufferGeometry(parseFloat(this.innerRadius),parseFloat(this.outerRadius),parseInt(this.thetaSegments,10),parseInt(this.phiSegments,10),parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},e.VglScene={mixins:[H],props:{/** the color, near and far parameters of the scene's fog */fog:{type:D},/**
       * Expecting to accept a string representing a color.
       * Will be overwrited by backgroundTexture prop if both props are set
      */backgroundColor:L,/** Expecting to accept a string representing a texture name. */backgroundTexture:L},computed:{inst:function(){return new t.Scene}},methods:{setBackgroundTexture:function(){var e=this.vglNamespace.textures,t=this.inst,a=this.backgroundTexture;a in e&&(t.background=e[a])}},created:function(){var e=this.vglNamespace.beforeRender,t=this.setBackgroundTexture;e.unshift(t)},watch:{inst:{handler:function(e){this.vglNamespace.scenes[this.name]=e,this.fog&&(this.inst.fog=x(this.fog)),this.backgroundColor&&(this.inst.background=N(this.backgroundColor)),this.backgroundTexture&&(this.inst.background=this.vglNamespace.textures[this.backgroundTexture]||null)},immediate:!0},name:function(e,t){var a=this.vglNamespace.scenes,i=this.inst;a[t]===i&&delete a[t],a[e]=i},fog:function(e){this.inst.fog=x(e)},backgroundColor:function(e){this.inst.background=N(e)},backgroundTexture:function(e){this.inst.background=this.vglNamespace.textures[e]||null}},beforeDestroy:function(){var e=this.vglNamespace,t=e.scenes,a=e.beforeRender,i=this.inst,r=this.setBackgroundTexture;t[this.name]===i&&delete t[this.name],a.splice(a.indexOf(r),1)}},e.VglShadowMaterial={mixins:[$],computed:{inst:function(){return new t.ShadowMaterial}}},e.VglSphereGeometry={mixins:[U],props:{/** Sphere radius. */radius:{type:V,default:1},/** Number of horizontal segments. */widthSegments:{type:V,default:8},/** Number of vertical segments. */heightSegments:{type:V,default:6},/** Specify horizontal starting angle. */phiStart:{type:V,default:0},/** Specify horizontal sweep angle size. */phiLength:{type:V,default:2*w},/** Specify vertical starting angle. */thetaStart:{type:V,default:0},/** Specify vertical sweep angle size. */thetaLength:{type:V,default:w}},computed:{inst:function(){return new t.SphereBufferGeometry(parseFloat(this.radius),parseInt(this.widthSegments,10),parseInt(this.heightSegments,10),parseFloat(this.phiStart),parseFloat(this.phiLength),parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},e.VglSpotLight={mixins:[k],props:{/**
       * The distance from the light where the intensity is 0.
       * When set to 0, then the light never stops.
       */distance:{type:V,default:0},/**
       * The amount the light dims along the distance of the light.
       * For physically correct lighting, set this to 2.
       */decay:{type:V,default:1},/**
       * Maximum extent of the spotlight, in radians, from its direction.
       * Should be no more than Math.PI/2.
       */angle:{type:V,default:w/3},/**
       * Percent of the spotlight cone that is attenuated due to penumbra.
       * Takes values between zero and 1.
       */penumbra:{type:V,default:0},/** The spotlight's pointing position. */target:A},computed:{inst:function(){return new t.SpotLight}},beforeDestroy:function(){this.inst.target.parent&&this.inst.target.parent.remove(this.inst.target)},watch:{inst:{handler:function(e){Object.assign(e,{distance:parseFloat(this.distance),decay:parseFloat(this.decay),angle:parseFloat(this.angle),penumbra:parseFloat(this.penumbra)}),this.target&&e.target.position.copy(h(this.target)),this.vglObject3d.inst&&this.vglObject3d.inst.add(e.target)},immediate:!0},"vglObject3d.inst":function(e){e.add(this.inst.target)},distance:function(e){this.inst.distance=parseFloat(e)},decay:function(e){this.inst.decay=parseFloat(e)},angle:function(e){this.inst.angle=parseFloat(e)},penumbra:function(e){this.inst.penumbra=parseFloat(e)},target:function(e){this.inst.target.position.copy(h(e))}}},e.VglSpotLightHelper={mixins:[H],props:{/** If this is not the set the helper will take the color of the light. */color:{type:L},/** Name of the spot light being visualized. */light:L},methods:{setHelper:function(){if(this.inst.children.length){var e=s(this.inst.children,1),a=e[0];a.light===this.vglNamespace.object3ds[this.light]?(a.color=this.color,a.update()):(this.inst.remove(a),a.dispose(),this.inst.add(new t.SpotLightHelper(this.vglNamespace.object3ds[this.light],this.color)))}else this.inst.add(new t.SpotLightHelper(this.vglNamespace.object3ds[this.light],this.color))}},created:function(){this.vglNamespace.beforeRender.push(this.setHelper)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setHelper,a=this.inst.children;e.splice(e.indexOf(t),1),a.length&&a[0].dispose()}},e.VglSprite={mixins:[W],props:{/** Name of the material, defining the object's appearance. */material:L},computed:{inst:function(){return new t.Sprite}}},e.VglSpriteMaterial={mixins:[I],props:{/** CSS style color of the material. */color:{type:L,default:"#fff"},/** The texture map of the material. */map:L},computed:{inst:function(){return new t.SpriteMaterial}},watch:{inst:{handler:function(e){e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)}}},e.VglTetrahedronGeometry={mixins:[U],props:{/** Radius of the tetrahedron. */radius:{type:V,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a tetrahedron. */detail:{type:V,default:0}},computed:{inst:function(){return new t.TetrahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},e.VglTextGeometry={mixins:[ae],props:{/** The text that needs to be shown. */text:{type:L,default:""},/** The path or URL to the facetype json file. This can also be a Data URI. */font:L,/** Size of the text. */size:{type:V,default:100},/** Thickness to extrude text. */height:{type:V,default:50},/** Number of points on the curves. */curveSegments:{type:V,default:12},/** Turn on bevel. */bevelEnabled:R,/** How deep into text bevel goes. */bevelThickness:{type:V,default:10},/** How far from text outline is bevel. */bevelSize:{type:V,default:8},/** Number of bevel segments. */bevelSegments:{type:V,default:3}},data:function(){return{f:void 0}},computed:{inst:function(){return this.f===void 0?new t.BufferGeometry:new t.TextBufferGeometry(this.text,{font:ie[this.f],size:parseFloat(this.size),height:parseFloat(this.height),curveSegments:parseInt(this.curveSegments,10),bevelEnabled:this.bevelEnabled,bevelThickness:parseFloat(this.bevelThickness),bevelSize:parseFloat(this.bevelSize),bevelSegments:parseInt(this.bevelSegments,10)})}},watch:{font:{handler:function(e){var a=this;ie[e]?ie[e].isFont?this.f=e:ie[e].push(function(){e===a.font&&(a.f=e)}):(ie[e]=[function(){e===a.font&&(a.f=e),a.vglNamespace.update()}],new t.FontLoader().load(e,function(t){var a=ie[e];ie[e]=t,a.forEach(function(e){e()})}))},immediate:!0}}},e.VglTexture={inject:["vglNamespace"],props:{/** The path or URL to the file. This can also be a Data URI. */src:L,name:L,mapping:{type:L,default:"uv"},wrapS:{type:L,default:"clamp-to-edge"},wrapT:{type:L,default:"clamp-to-edge"},magFilter:{type:L,default:"linear"},minFilter:{type:L,default:"linear-mip-map-linear"},anisotropy:{type:V,default:1},format:L,type:{type:L,default:"unsigned-byte"},offset:T,repeat:T,rotation:{type:V,default:0},center:T,premultiplyAlpha:R,unpackAlignment:{type:V,default:4},encoding:{type:L,default:"linear"}},computed:{inst:function(){var e=this;return new t.TextureLoader().load(this.src,function(t){e.format&&Object.assign(t,{format:Z[e.format]}),e.vglNamespace.update()})}},watch:{inst:{handler:function(e){this.vglNamespace.textures[this.name]=e,Object.assign(e,{mapping:J[this.mapping],wrapS:X[this.wrapS],wrapT:X[this.wrapT],magFilter:Y[this.magFilter],minFilter:Y[this.minFilter],anisotropy:parseInt(this.anisotropy,10),type:ee[this.type],rotation:parseFloat(this.rotation),premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:parseInt(this.unpackAlignment,10),encoding:te[this.encoding]}),this.offset&&e.offset.copy(f(this.offset)),this.repeat&&e.repeat.copy(f(this.repeat)),this.center&&e.center.copy(f(this.center))},immediate:!0},name:function(e,t){var a=this.vglNamespace.textures,i=this.inst;a[t]===i&&delete a[t],a[e]=i},mapping:function(e){this.inst.mapping=J[e]},wrapS:function(e){this.inst.wrapS=X[e]},wrapT:function(e){this.inst.wrapT=X[e]},magFilter:function(e){this.inst.magFilter=Y[e]},minFilter:function(e){this.inst.minFilter=Y[e]},anisotropy:function(e){this.inst.anisotropy=parseInt(e,10)},format:function(e){this.inst.format=Z[e]},type:function(e){this.inst.type=ee[e]},offset:function(e){this.inst.offset.copy(f(e))},repeat:function(e){this.inst.repeat.copy(f(e))},rotation:function(e){this.inst.rotation=parseFloat(e)},center:function(e){this.inst.center.copy(f(e))},premultiplyAlpha:function(e){this.inst.premultiplyAlpha=e},unpackAlignment:function(e){this.inst.unpackAlignment=parseInt(e,10)},encoding:function(e){this.inst.encoding=te[e]}},beforeDestroy:function(){var e=this.vglNamespace.textures,t=this.inst,a=this.name;e[a]===t&&delete e[a]},beforeUpdate:function(){this.inst.needsUpdate=!0,this.vglNamespace.update()},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},e.VglTorusGeometry={mixins:[U],props:{/** Radius of the torus. */radius:{type:V,default:1},/** Diamiter of the tube. */tube:{type:V,default:.4},/** Number of segments of the tube's section. */radialSegments:{type:V,default:8},/** Number of segments along to the tube length direction. */tubularSegments:{type:V,default:6},/** The central angle. */arc:{type:V,default:2*w}},computed:{inst:function(){return new t.TorusBufferGeometry(parseFloat(this.radius),parseFloat(this.tube),parseInt(this.radialSegments,10),parseInt(this.tubularSegments,10),parseFloat(this.arc))}}},e.VglTorusKnotGeometry={mixins:[U],props:{/** Radius of the torus. */radius:{type:V,default:1},/** Diamiter of the tube. */tube:{type:V,default:.4},/** Number of segments of the tube's section. */radialSegments:{type:V,default:8},/** Number of segments along to the tube length direction. */tubularSegments:{type:V,default:64},/**
       * This value determines how many times the geometry winds
       * around its axis of rotational symmetry.
       */p:{type:V,default:2},/**
       * This value determines how many times the geometry winds
       * around a circle in the interior of the torus.
       */q:{type:V,default:3}},computed:{inst:function(){return new t.TorusKnotBufferGeometry(parseFloat(this.radius),parseFloat(this.tube),parseInt(this.tubularSegments,10),parseInt(this.radialSegments,10),parseInt(this.p,10),parseInt(this.q,10))}}},Object.defineProperty(e,"__esModule",{value:!0})});
