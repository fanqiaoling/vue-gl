(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):(e=e||self,t(e.VueGL={},e.THREE))})(this,function(e,t){'use strict';var w=Math.PI;function i(e,t){return i=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},i(e,t)}function a(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],function(){})),!0}catch(t){return!1}}function r(){return r=a()?Reflect.construct:function(e,t,r){var n=[null];n.push.apply(n,t);var a=Function.bind.apply(e,n),s=new a;return r&&i(s,r.prototype),s},r.apply(null,arguments)}function n(e,t){return l(e)||p(e,t)||m()}function s(e){return o(e)||d(e)||c()}function o(e){if(Array.isArray(e)){for(var t=0,a=Array(e.length);t<e.length;t++)a[t]=e[t];return a}}function l(e){if(Array.isArray(e))return e}function d(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}function p(e,t){var i=[],a=!0,r=!1,n=void 0;try{for(var s,o=e[Symbol.iterator]();!(a=(s=o.next()).done)&&(i.push(s.value),!(t&&i.length===t));a=!0);}catch(e){r=!0,n=e}finally{try{a||null==o["return"]||o["return"]()}finally{if(r)throw n}}return i}function c(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function m(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}/**
   * Returns a parsed quaternion object.
   */function u(e){return e.isQuaternion?e:r(t.Quaternion,s(e.trim().split(/\s+/).map(function(e){return parseFloat(e)})))}/**
   * Returns a parsed vector3 object.
   */function g(e){return e.isVector3?e:r(t.Vector3,s(e.trim().split(/\s+/).map(function(e){return parseFloat(e)})))}/**
   * Returns a parsed vector2 object.
   */function h(e){return e.isVector2?e:r(t.Vector2,s(e.trim().split(/\s+/).map(function(e){return parseFloat(e)})))}/**
   * Returns a parsed euler object.
   */function f(e){return e.isEuler?e:r(t.Euler,s(e.trim().split(/\s+/).map(function(e,t){return 3===t?e:parseFloat(e)})))}/**
   * Returns a parsed spherical object.
   */function y(e){return e.isSpherical?e:r(t.Spherical,s(e.trim().split(/\s+/).map(function(e){return parseFloat(e)}))).makeSafe()}/**
   * Returns a parsed array.
   */function b(e){return Array.isArray(e)?e:e.split(",")}/**
   * Returns a parsed array of vector2.
   */function v(e){return b(e).map(function(e){return h(e)})}/**
   * Returns a parsed fog object
   */function S(e){return e.isFog?e:r(t.Fog,s(e.trim().split(/\s+/).map(function(e,t){return 0===t?e:parseFloat(e)})))}/**
   * Returns a parsed Color object
   */function x(e){return e.isColor?e:new t.Color(e)}var N={inject:{vglNamespace:{default:function(){var e,t=this,i=[],a=[];return{renderers:i,cameras:Object.create(null),scenes:Object.create(null),update:function(){e||(t.$nextTick(function(){a.forEach(function(e){e()}),i.forEach(function(e){e.render()}),e=!1}),e=!0)},beforeRender:a,geometries:Object.create(null),materials:Object.create(null),textures:Object.create(null),object3ds:Object.create(null)}}}},provide:function(){return{vglNamespace:Object.create(this.vglNamespace,{geometries:{value:Object.create(this.vglNamespace.geometries)},materials:{value:Object.create(this.vglNamespace.materials)},textures:{value:Object.create(this.vglNamespace.textures)},object3ds:{value:Object.create(this.vglNamespace.object3ds)}})}},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},M=[String,Number],L=String,V=[String,t.Vector3],A=[String,t.Spherical],C=Boolean,R=[String,t.Euler],G=[String,t.Vector2],T=[String,t.Quaternion],B=[String,Array],j=[String,Array],z=[String,t.Fog],D=[String,Array],P={props:{/** The object's local position as a 3D vector. */position:V,/** The object's local rotation as a euler angle. */rotation:R,/**
       * The object's local rotation as a quaternion (specified in x, y, z, w order).
       * Do not use in conjunction with the rotation prop, since they both control the same property
       * of the underlying THREE.Object3D object.
       */rotationQuaternion:T,/** The object's local scale as a 3D vector. */scale:V,/** Whether the object gets rendered into shadow map. */castShadow:C,/** Whether the material receives shadows. */receiveShadow:C,/** Optional name of the object. */name:L,/** Whether the object is visible. */visible:{type:C,default:!0}},computed:{inst:function(){return new t.Object3D}},inject:{vglObject3d:{default:{}},vglNamespace:"vglNamespace"},provide:function(){var e=this;return{vglObject3d:{get inst(){return e.inst}}}},created:function(){this.vglNamespace.update()},beforeUpdate:function(){this.vglNamespace.update()},beforeDestroy:function(){var e=this.vglNamespace,t=this.inst,i=this.name;t.parent&&t.parent.remove(t),e.object3ds[i]===t&&delete e.object3ds[i],e.update()},watch:{inst:{handler:function(e,t){t&&t.parent&&t.parent.remove(t),this.vglObject3d.inst&&this.vglObject3d.inst.add(e),this.position&&e.position.copy(g(this.position)),this.rotation&&e.rotation.copy(f(this.rotation)),this.rotationQuaternion&&e.quaternion.copy(u(this.rotationQuaternion)),this.scale&&e.scale.copy(g(this.scale)),Object.assign(e,{castShadow:this.castShadow,receiveShadow:this.receiveShadow,visible:this.visible}),this.name!==void 0&&(e.name=this.name,this.vglNamespace.object3ds[this.name]=e)},immediate:!0},"vglObject3d.inst":function(e){e.add(this.inst)},position:function(e){this.inst.position.copy(g(e))},rotation:function(e){this.inst.rotation.copy(f(e))},rotationQuaternion:function(e){this.inst.quaternion.copy(u(e))},scale:function(e){this.inst.scale.copy(g(e))},castShadow:function(e){this.inst.castShadow=e},receiveShadow:function(e){this.inst.receiveShadow=e},name:function(e,t){var i=this.vglNamespace.object3ds,a=this.inst;i[t]===a&&delete i[t],this.inst.name=e,i[e]=a},visible:function(e){this.inst.visible=e}},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},H={mixins:[P],props:{/**
       * Position in 3D space for the camera to point towards.
       * This property overwrite rotation property when both defined.
       */orbitTarget:V,/**
       * Spherical position around orbitTarget.
       * This property overwrite position and rotation properties.
       * If orbitTarget is not defined, automatically set to (0, 0, 0).
       */orbitPosition:A},computed:{inst:function(){return new t.Camera}},watch:{inst:{handler:function(e){if(this.vglNamespace.cameras[this.name]=e,this.orbitPosition||this.orbitTarget){var i;this.orbitTarget&&(i=g(this.orbitTarget)),this.orbitPosition&&(e.position.setFromSpherical(y(this.orbitPosition)),i&&e.position.add(i)),e.lookAt(i||new t.Vector3)}},immediate:!0},name:function(e,t){var i=this.vglNamespace.cameras,a=this.inst;i[t]===a&&delete i[t],i[e]=a},orbitTarget:function(e){var t=g(e);this.orbitPosition&&this.inst.position.setFromSpherical(y(this.orbitPosition)).add(t),this.inst.lookAt(t)},orbitPosition:function(e){if(this.inst.position.setFromSpherical(y(e)),this.orbitTarget){var i=g(this.orbitTarget);this.inst.position.add(i),this.inst.lookAt(i)}else this.inst.lookAt(new t.Vector3)}},beforeDestroy:function(){var e=this.vglNamespace.cameras,t=this.inst;e[this.name]===t&&delete e[this.name]}},F={mixins:[P],props:{/** CSS style color of the light. */color:{type:L,default:"#fff"},/** Numeric value of the light's strength/intensity. */intensity:{type:M,default:1}},computed:{inst:function(){return new t.Light}},watch:{inst:{handler:function(e){e.color.setStyle(this.color),Object.assign(e,{intensity:parseFloat(this.intensity)})},immediate:!0},color:function(e){this.inst.color.setStyle(e)},intensity:function(e){this.inst.intensity=parseFloat(e)}}},k={no:t.NoColors,vertex:t.VertexColors,face:t.FaceColors},E={front:t.FrontSide,back:t.BackSide,double:t.DoubleSide},O={inject:["vglNamespace"],props:{/** Name of the material. */name:L,/** Defines which side of faces will be rendered. front, back or double. */side:{type:L,default:"front"},/** Defines whether vertex coloring is used. Other options are 'vertex' and 'face'. */vertexColors:{type:L,default:"no"}},computed:{inst:function(){return new t.Material}},watch:{inst:{handler:function(e){e.setValues({side:E[this.side],vertexColors:k[this.vertexColors]}),this.vglNamespace.materials[this.name]=e},immediate:!0},name:function(e,t){var i=this.vglNamespace.materials,a=this.inst;i[t]===a&&delete i[t],i[e]=a},side:function(e){this.inst.side=E[e]},vertexColors:function(e){this.inst.vertexColors=k[e]}},beforeDestroy:function(){var e=this.vglNamespace.materials,t=this.inst;e[this.name]===t&&delete e[this.name]},created:function(){this.vglNamespace.update()},beforeUpdate:function(){this.vglNamespace.update()},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},$={inject:["vglNamespace"],props:{/** Name of the component. */name:L,/** The x, y, and z coordinates of each vertex in this geometry. */positionAttribute:B,/** The red, green, and blue channels of vertex color of each vertex in this geometry. */colorAttribute:B,/** The x, y, and z components of the vertex normal vector of each vertex in this geometry. */normalAttribute:B},computed:{inst:function(){return new t.BufferGeometry}},watch:{inst:{handler:function(e,i){if(this.positionAttribute){var a=i?i.getAttribute("position"):new t.BufferAttribute(new Float32Array(b(this.positionAttribute)),3);e.addAttribute("position",a)}if(this.colorAttribute){var r=i?i.getAttribute("color"):new t.BufferAttribute(new Float32Array(b(this.colorAttribute)),3);e.addAttribute("color",r)}if(this.normalAttribute){var n=i?i.getAttribute("normal"):new t.BufferAttribute(new Float32Array(b(this.normalAttribute)),3);e.addAttribute("normal",n)}i&&i.dispose(),this.vglNamespace.geometries[this.name]=e},immediate:!0},name:function(e,t){var i=this.vglNamespace.geometries,a=this.inst;i[t]===a&&delete i[t],i[e]=a},positionAttribute:function(e){var t=b(e),i=this.inst.getAttribute("position");i.array.length===t.length?i.copyArray(t):i.setArray(new Float32Array(t)),i.needsUpdate=!0},colorAttribute:function(e){var t=b(e),i=this.inst.getAttribute("color");i.array.length===t.length?i.copyArray(t):i.setArray(new Float32Array(t)),i.needsUpdate=!0},normalAttribute:function(e){var t=b(e),i=this.inst.getAttribute("normal");i.array.length===t.length?i.copyArray(t):i.setArray(new Float32Array(t)),i.needsUpdate=!0}},beforeDestroy:function(){var e=this.vglNamespace.geometries,t=this.inst;e[this.name]===t&&delete e[this.name],t.dispose()},created:function(){this.vglNamespace.update()},beforeUpdate:function(){this.vglNamespace.update()},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},U={mixins:[P],methods:{setMaterial:function(){var e=this.vglNamespace.materials,t=this.material,i=this.inst;Array.isArray(t)?i.material=t.reduce(function(t,i){return e[i]?[].concat(s(t),[e[i]]):t},[]):e[t]&&(i.material=e[t])}},created:function(){this.vglNamespace.beforeRender.unshift(this.setMaterial)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setMaterial;e.splice(e.indexOf(t),1)}},W={mixins:[U],methods:{setGeometry:function(){var e=this.vglNamespace.geometries,t=this.geometry,i=this.inst;e[t]&&(i.geometry=e[t])}},created:function(){this.vglNamespace.beforeRender.unshift(this.setGeometry)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setGeometry;e.splice(e.indexOf(t),1)}},_={mixins:[O],methods:{setMap:function(){var e=this.vglNamespace.textures,t=this.inst,i=this.map;i in e&&(t.map=e[i])}},created:function(){this.vglNamespace.beforeRender.unshift(this.setMap)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setMap;e.splice(e.indexOf(t),1)}},I={mixins:[_],props:{/** CSS style color of the material. */color:{type:L,default:"#fff"},/** The color map of the material. */map:L},computed:{inst:function(){return new t.MeshStandardMaterial}},watch:{inst:{handler:function(e){e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)}}},q={mixins:[W],props:{/** Name of the geometry, representing the line segment(s). */geometry:L,/** Name of the material for the line. */material:L},computed:{inst:function(){return new t.Line}},methods:{computeLineDistances:function(){this.inst.material.isLineDashedMaterial&&this.inst.computeLineDistances()}},created:function(){this.vglNamespace.beforeRender.push(this.computeLineDistances)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.computeLineDistances;e.splice(e.indexOf(t),1)}},Q={mixins:[$],props:{/** Radius of the cylinder at the top. */radiusTop:{type:M,default:1},/** Radius of the cylinder at the bottom. */radiusBottom:{type:M,default:1},/** Height of the cylinder. */height:{type:M,default:1},/** Number of segmented faces around the circumference of the cylinder. */radialSegments:{type:M,default:8},/** Number of rows of faces along the height of the cylinder. */heightSegments:{type:M,default:1},/** A Boolean indicating whether the ends of the cylinder are open or capped. */openEnded:C,/** Start angle for first segment. */thetaStart:{type:M,default:0},/** The central angle of the circular sector. */thetaLength:{type:M,default:2*w}},computed:{inst:function(){return new t.CylinderBufferGeometry(parseFloat(this.radiusTop),parseFloat(this.radiusBottom),parseFloat(this.height),parseInt(this.radialSegments,10),parseInt(this.heightSegments,10),this.openEnded,parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},K={uv:t.UVMapping,"cube-reflection":t.CubeReflectionMapping,"cube-refraction":t.CubeRefractionMapping,"equirectangular-reflection":t.EquirectangularReflectionMapping,"equirectangular-refraction":t.EquirectangularRefractionMapping,"spherical-reflection":t.SphericalReflectionMapping,"cube-uv-reflection":t.CubeUVReflectionMapping,"cube-uv-refraction":t.CubeUVRefractionMapping},J={repeat:t.RepeatWrapping,"clamp-to-edge":t.ClampToEdgeWrapping,"mirrored-repeat":t.MirroredRepeatWrapping},X={nearest:t.NearestFilter,"nearest-mip-map-nearest":t.NearestMipMapNearestFilter,"nearest-mip-map-linear":t.NearestMipMapLinearFilter,linear:t.LinearFilter,"linear-mip-map-nearest":t.LinearMipMapNearestFilter,"linear-mip-map-linear":t.LinearMipMapLinearFilter},Y={alpha:t.AlphaFormat,rgb:t.RGBFormat,rgba:t.RGBAFormat,luminance:t.LuminanceFormat,"luminance-alpha":t.LuminanceAlphaFormat,rgbe:t.RGBEFormat,depth:t.DepthFormat,"depth-stencil":t.DepthStencilFormat},Z={"unsigned-byte":t.UnsignedByteType,byte:t.ByteType,short:t.ShortType,"unsigned-short":t.UnsignedShortType,int:t.IntType,"unsigned-int":t.UnsignedIntType,float:t.FloatType,"half-float":t.HalfFloatType,"unsigned-short-4444":t.UnsignedShort4444Type,"unsigned-short-5551":t.UnsignedShort5551Type,"unsigned-short-565":t.UnsignedShort565Type,"unsigned-int-248":t.UnsignedInt248Type},ee={linear:t.LinearEncoding,"s-rgb":t.sRGBEncoding,gamma:t.GammaEncoding,rgbe:t.RGBEEncoding,"log-luv":t.LogLuvEncoding,rgbm7:t.RGBM7Encoding,rgbm16:t.RGBM16Encoding,rgbde:t.RGBDEncoding,"basic-depth":t.BasicDepthPacking,"rgba-depth":t.RGBADepthPacking},te={mixins:[$],computed:{inst:function(){return new t.ExtrudeBufferGeometry([],{})}}},ie=Object.create(null),ae={mixins:[_],props:{/** CSS style color of the material. */color:{type:L,default:"#fff"},/** The color map of the material. */map:L,/** Specular color of the material. */specular:{type:L,default:"#111111"},/** How shiny the specular highlight is. A higher value gives a sharper highlight. */shininess:{type:M,default:30}},computed:{inst:function(){return new t.MeshPhongMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{shininess:parseFloat(this.shininess)}),e.specular.setStyle(this.specular),e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)},specular:function(e){this.inst.specular.setStyle(e)},shininess:function(e){this.inst.shininess=parseFloat(e)}}},re={mixins:[_],props:{/**
       * Defines custom constants using `#define` directives within the GLSL code for both the vertex
       * shader and the fragment shader; each key/value pair yields another directive:
       * ```
       * defines: {
       *     FOO: 15,
       *     BAR: true
       * }
       * ```
       * yields the lines
       * ```
       * #define FOO 15
       * #define BAR true
       * ```
       * in the GLSL code.
       * @default {}
       */defines:{type:Object,default:function(){return{}}},/**
       * Define whether the material color is affected by global fog settings; true to pass fog
       * uniforms to the shader. Note that changing this value will cause the material to be
       * reconstructed, so be aware of performance if using this reactively. Also note that when using
       * this, THREE expects fog-related uniforms to be defined on your material; you can use
       * something like the following to include them:
       * ```
       * uniforms: THREE.UniformsUtils.merge([
       *    THREE.UniformsLib['fog'],
       *    { other uniforms... }
       * ]),
       * ```
       */fog:{type:C,default:!1},/**
       * Fragment shader GLSL code. This is the actual code for the shader.
       * @default The default fragment shader provided by three.js
       */fragmentShader:{type:L},/**
       * Defines whether this material uses lighting; true to pass uniform data related to lighting to
       * this shader. Note that changing this value will cause the material to be reconstructed, so be
       * aware of performance if using this reactively. Also note that when using this, THREE expects
       * lighting-related uniforms to be defined on your material; you can use something like the
       * following to include them:
       * ```
       * uniforms: THREE.UniformsUtils.merge([
       *    THREE.UniformsLib['lights'],
       *    { other uniforms... }
       * ]),
       * ```
       */lights:{type:C,default:!1},/**
       * Controls wireframe thickness. Due to limitations of the OpenGL Core Profile with the WebGL
       * renderer on most platforms `linewidth` will always be 1 regardless of the set value.
       */linewidth:{type:M,default:1},/** Define whether the material is rendered with flat shading. */flatShading:{type:C,default:!1},/**
       * An object of the form:
       * ```
       * { "uniform1": { value: 1.0 }, "uniform2": { value: 2 } }
       * ```
       * specifying the uniforms to be passed to the shader code; keys are uniform names, values are
       * definitions of the form
       * ```
       * { value: 1.0 }
       * ```
       * where value is the value of the uniform. Names must match the name of the uniform, as defined
       * in the GLSL code. Note that uniforms are refreshed on every frame, so updating the value of
       * the uniform will immediately update the value available to the GLSL code. */uniforms:{type:Object,default:function(){return{}}},/**
       * Vertex shader GLSL code. This is the actual code for the shader.
       * @default The default vertex shader provided by three.js
       */vertexShader:{type:L},/**
       * Render geometry as wireframe (using `GL_LINES` instead of `GL_TRIANGLES`).
       */wireframe:{type:C,default:!1},/**
       * Controls wireframe thickness. Due to limitations of the OpenGL Core Profile with the WebGL
       * renderer on most platforms `linewidth` will always be 1 regardless of the set value.
       */wireframeLinewidth:{type:M,default:1}},computed:{inst:function(){return new t.ShaderMaterial({fog:this.fog,lights:this.lights})}},watch:{inst:{handler:function(e){Object.assign(e,{defines:this.defines,fog:this.fog,fragmentShader:this.fragmentShader||e.fragmentShader,lights:this.lights,linewidth:parseFloat(this.linewidth),flatShading:this.flatShading,uniforms:this.uniforms,vertexShader:this.vertexShader||e.vertexShader,wireframe:this.wireframe,wireframeLinewidth:parseFloat(this.wireframeLinewidth)})},immediate:!0},defines:{handler:function(e){this.inst.defines=e,this.inst.needsUpdate=!0},deep:!0},fragmentShader:function(e){this.inst.fragmentShader=e,this.inst.needsUpdate=!0},linewidth:function(e){this.inst.linewidth=parseFloat(e)},flatShading:function(e){this.inst.flatShading=e,this.inst.needsUpdate=!0},uniforms:{handler:function(e){this.inst.uniforms=e},deep:!0},vertexShader:function(e){this.inst.vertexShader=e,this.inst.needsUpdate=!0},wireframe:function(e){this.inst.wireframe=e},wireframeLinewidth:function(e){this.inst.wireframeLinewidth=parseFloat(e)}}};e.VglAmbientLight={mixins:[F],computed:{inst:function(){return new t.AmbientLight}}},e.VglArrowHelper={mixins:[P],props:{/** Direction from origin. */dir:V,/** Length of the arrow. */length:{type:M,default:1},/** Color of the arrow. */color:{type:L,default:"#ff0"},/** The length of the head of the arrow. */headLength:M,/** The width of the head of the arrow. */headWidth:M},computed:{inst:function(){return new t.ArrowHelper(new t.Vector3(0,1,0),new t.Vector3())},len:function(){return[parseFloat(this.length),this.headLength===void 0?void 0:parseFloat(this.headLength),this.headWidth===void 0?void 0:parseFloat(this.headWidth)]}},watch:{inst:{handler:function(e){this.dir&&e.setDirection(g(this.dir).normalize()),e.setLength.apply(e,s(this.len)),e.setColor(new t.Color(this.color))},immediate:!0},dir:function(e){this.inst.setDirection(g(e).normalize())},len:function(e){var t;(t=this.inst).setLength.apply(t,s(e))},color:function(e){this.inst.setColor(new t.Color(e))}}},e.VglAxesHelper={mixins:[P],props:{/** Size of the lines representing the axes. */size:{type:M,default:1}},computed:{inst:function(){return new t.AxesHelper(parseFloat(this.size))}}},e.VglBoxGeometry={mixins:[$],props:{/** Width of the sides on the X axis. */width:{type:M,default:1},/** Height of the sides on the Y axis. */height:{type:M,default:1},/** Depth of the sides on the Z axis. */depth:{type:M,default:1},/** Number of segmented faces along the width of the sides. */widthSegments:{type:M,default:1},/** Number of segmented faces along the height of the sides. */heightSegments:{type:M,default:1},/** Number of segmented faces along the depth of the sides. */depthSegments:{type:M,default:1}},computed:{inst:function(){return new t.BoxBufferGeometry(parseFloat(this.width),parseFloat(this.height),parseFloat(this.depth),parseInt(this.widthSegments,10),parseInt(this.heightSegments,10),parseInt(this.depthSegments,10))}}},e.VglBoxHelper={mixins:[P],props:{/** Size of the lines representing the axes. */color:{type:L,default:"#ff0"},/** Name of the object to show the world-axis-aligned boundingbox. */object:L},computed:{inst:function(){return new t.BoxHelper(void 0,this.color)}},methods:{setFromObject:function(){this.inst.setFromObject(this.vglNamespace.object3ds[this.object])}},created:function(){this.vglNamespace.beforeRender.push(this.setFromObject)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setFromObject;e.splice(e.indexOf(t),1)}},e.VglCamera=H,e.VglCameraHelper={mixins:[P],props:{/** Name of the camera to visualize. */camera:L},methods:{setHelper:function(){if(!this.inst.children.length)this.inst.add(new t.CameraHelper(this.vglNamespace.cameras[this.camera]));else{var e=n(this.inst.children,1),i=e[0];i.camera=this.vglNamespace.cameras[this.camera],i.camera.updateProjectionMatrix(),i.update()}}},created:function(){this.vglNamespace.beforeRender.push(this.setHelper)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setHelper;e.splice(e.indexOf(t),1)}},e.VglCircleGeometry={mixins:[$],props:{/** Radius of the circle. */radius:{type:M,default:1},/** Number of segments (triangles). */segments:{type:M,default:8},/** Start angle for first segment. */thetaStart:{type:M,default:0},/** The central angle of the circular sector. */thetaLength:{type:M,default:2*w}},computed:{inst:function(){return new t.CircleBufferGeometry(parseFloat(this.radius),parseInt(this.segments,10),parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},e.VglConeGeometry={mixins:[Q],props:{/** Radius of the cone at the base. */radius:{type:M,default:1}},computed:{inst:function(){return new t.ConeBufferGeometry(parseFloat(this.radius),parseFloat(this.height),parseInt(this.radialSegments,10),parseInt(this.heightSegments,10),this.openEnded,parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},e.VglCylinderGeometry=Q,e.VglDirectionalLight={mixins:[F],computed:{inst:function(){return new t.DirectionalLight}}},e.VglDirectionalLightHelper={mixins:[P],props:{/** If this is not the set the helper will take the color of the light. */color:{type:L},/** Dimensions of the plane. */size:{type:M,default:1},/** Name of the directional light being visualized. */light:L},data:function(){return{s:void 0}},methods:{setHelper:function(){var e=this.vglNamespace.object3ds[this.light];if(this.inst.children.length){var i=n(this.inst.children,1),a=i[0];if(a.light===e&&this.s===this.size)return a.color=this.color,void a.update();this.inst.remove(a)}this.s=this.size,this.inst.add(new t.DirectionalLightHelper(e,parseFloat(this.size),this.color))}},created:function(){this.vglNamespace.beforeRender.push(this.setHelper)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setHelper;e.splice(e.indexOf(t),1)}},e.VglDodecahedronGeometry={mixins:[$],props:{/** Radius of the dodecahedron. */radius:{type:M,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a dodecahedron. */detail:{type:M,default:0}},computed:{inst:function(){return new t.DodecahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},e.VglExtrudeGeometry=te,e.VglGeometry=$,e.VglGridHelper={mixins:[P],props:{/** The size of the grid. */size:{type:M,default:10},/** The number of divisions across the grid. */divisions:{type:M,default:10},/** The color of the centerline. */colorCenterLine:{type:L,default:"#444444"},/** The color of the lines of the grid. */colorGrid:{type:L,default:"#888888"}},computed:{inst:function(){return new t.GridHelper(parseFloat(this.size),parseInt(this.divisions,10),this.colorCenterLine,this.colorGrid)}}},e.VglGroup={mixins:[P],computed:{inst:function(){return new t.Group}}},e.VglHemisphereLight={mixins:[F],props:{groundColor:{type:L,default:"#fff"}},computed:{inst:function(){return new t.HemisphereLight}},watch:{inst:{handler:function(e){e.groundColor.setStyle(this.groundColor)},immediate:!0},groundColor:function(e){this.inst.groundColor.setStyle(e)}}},e.VglIcosahedronGeometry={mixins:[$],props:{/** Radius of the icosahedron. */radius:{type:M,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a icosahedron. */detail:{type:M,default:0}},computed:{inst:function(){return new t.IcosahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},e.VglLatheGeometry={mixins:[$],props:{/** Array of Vector2s. The x-coordinate of each point must be greater than zero. */points:{type:j,required:!0},/** The number of circumference segments to generate. */segments:{type:M,default:12},/** The starting angle in radians. */phiStart:{type:M,default:0},/** The radian (0 to 2PI) range of the lathed section. */phiLength:{type:M,default:2*w}},computed:{inst:function(){return new t.LatheBufferGeometry(v(this.points),parseInt(this.segments,10),parseFloat(this.phiStart),parseFloat(this.phiLength))}}},e.VglLight=F,e.VglLine=q,e.VglLineBasicMaterial={mixins:[O],props:{/** CSS style color of the material. */color:{type:L,default:"#fff"},/** A boolean whether the material is affected by lights. */lights:C,/** The line thickness. */linewidth:{type:M,default:1},/** Define appearance of line ends. Possible values are "butt", "round" and "square". */linecap:{type:L,default:"round"},/** Define appearance of line joints. Possible values are "round", "bevel" and "miter". */linejoin:{type:L,default:"round"}},computed:{inst:function(){return new t.LineBasicMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{lights:this.lights,linecap:this.linecap,linejoin:this.linejoin,linewidth:parseFloat(this.linewidth)}),e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)},lights:function(e){this.inst.lights=e},linewidth:function(e){this.inst.linewidth=parseFloat(e)},linecap:function(e){this.inst.linecap=e},linejoin:function(e){this.inst.linejoin=e}}},e.VglLineDashedMaterial={mixins:[O],props:{/** CSS style color of the material. */color:{type:L,default:"#fff"},/** A boolean whether the material is affected by lights. */lights:C,/** The line thickness. */linewidth:{type:M,default:1},/** The size of the dash. This is both the gap with the stroke. */dashSize:{type:M,default:3},/** The size of the gap. */gapSize:{type:M,default:1}},computed:{inst:function(){return new t.LineDashedMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{lights:this.lights,dashSize:parseFloat(this.dashSize),gapSize:parseFloat(this.gapSize),linewidth:parseFloat(this.linewidth)}),e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)},lights:function(e){this.inst.lights=e},linewidth:function(e){this.inst.linewidth=parseFloat(e)},dashSize:function(e){this.inst.dashSize=parseFloat(e)},gapSize:function(e){this.inst.gapSize=parseFloat(e)}}},e.VglLineLoop={mixins:[q],computed:{inst:function(){return new t.LineLoop}}},e.VglLineSegments={mixins:[q],computed:{inst:function(){return new t.LineSegments}}},e.VglMaterial=O,e.VglMesh={mixins:[W],props:{/** Name of the geometry, defining the object's structure. */geometry:L,/**
       * A Material name or an array of Material name, defining the object's appearance.
       *
       * A single material will apply the material to all object's faces meanwhile
       * an array of material will apply each material to the matching index object's face
       */material:D},computed:{inst:function(){return new t.Mesh}}},e.VglMeshBasicMaterial={mixins:[_],props:{/** CSS style color of the material. */color:{type:L,default:"#fff"},/** The color map of the material. */map:L},computed:{inst:function(){return new t.MeshBasicMaterial}},watch:{inst:{handler:function(e){e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)}}},e.VglMeshDepthMaterial={mixins:[_],props:{/** Whether the material is affected by fog. */fog:C,/** The color map of the material. */map:L},computed:{inst:function(){return new t.MeshDepthMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{fog:this.fog})},immediate:!0},fog:function(e){this.inst.fog=e}}},e.VglMeshLambertMaterial={mixins:[_],props:{/** CSS style color of the material. */color:{type:L,default:"#fff"},/** The color map of the material. */map:L},computed:{inst:function(){return new t.MeshLambertMaterial}},watch:{inst:{handler:function(e){e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)}}},e.VglMeshNormalMaterial={mixins:[O],props:{/** Whether the material is affected by fog. */fog:C},computed:{inst:function(){return new t.MeshNormalMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{fog:this.fog})},immediate:!0},fog:function(e){this.inst.fog=e}}},e.VglMeshPhongMaterial=ae,e.VglMeshPhysicalMaterial={mixins:[I],props:{/** ClearCoat level, from 0.0 to 1.0. */clearCoat:{type:M,default:0},/** How rough the clearCoat appears, from 0.0 to 1.0. */clearCoatRoughness:{type:M,default:0},/** Degree of reflectivity, from 0.0 to 1.0. */reflectivity:{type:M,default:.5}},computed:{inst:function(){return new t.MeshPhysicalMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{clearCoat:parseFloat(this.clearCoat),clearCoatRoughness:parseFloat(this.clearCoatRoughness),reflectivity:parseFloat(this.reflectivity)})},immediate:!0},clearCoat:function(e){this.inst.clearCoat=parseFloat(e)},clearCoatRoughness:function(e){this.inst.clearCoatRoughness=parseFloat(e)},reflectivity:function(e){this.inst.reflectivity=parseFloat(e)}}},e.VglMeshStandardMaterial=I,e.VglMeshToonMaterial={mixins:[ae],computed:{inst:function(){return new t.MeshToonMaterial}}},e.VglNamespace=N,e.VglObject3d=P,e.VglOctahedronGeometry={mixins:[$],props:{/** Radius of the octahedron. */radius:{type:M,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a octahedron. */detail:{type:M,default:0}},computed:{inst:function(){return new t.OctahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},e.VglOrthographicCamera={mixins:[H],props:{/** Zoom factor of the camera. */zoom:{type:M,default:1},/** Camera frustum near plane. */near:{type:M,default:.1},/** Camera frustum far plane. */far:{type:M,default:2e3}},computed:{inst:function(){return new t.OrthographicCamera}},watch:{inst:{handler:function(e){Object.assign(e,{zoom:parseFloat(this.zoom),near:parseFloat(this.near),far:parseFloat(this.far)}),e.updateProjectionMatrix()},immediate:!0},zoom:function(e){this.inst.zoom=parseFloat(e),this.inst.updateProjectionMatrix()},near:function(e){this.inst.near=parseFloat(e),this.inst.updateProjectionMatrix()},far:function(e){this.inst.far=parseFloat(e),this.inst.updateProjectionMatrix()}}},e.VglPerspectiveCamera={mixins:[H],props:{/** Zoom factor of the camera. */zoom:{type:M,default:1},/** Camera frustum near plane. */near:{type:M,default:.1},/** Camera frustum far plane. */far:{type:M,default:2e3},/** Camera frustum vertical field of view, from bottom to top of view, in degrees. */fov:{type:M,default:50}},computed:{inst:function(){return new t.PerspectiveCamera}},watch:{inst:{handler:function(e){Object.assign(e,{zoom:parseFloat(this.zoom),near:parseFloat(this.near),far:parseFloat(this.far),fov:parseFloat(this.fov)}),e.updateProjectionMatrix()},immediate:!0},zoom:function(e){this.inst.zoom=parseFloat(e),this.inst.updateProjectionMatrix()},near:function(e){this.inst.near=parseFloat(e),this.inst.updateProjectionMatrix()},far:function(e){this.inst.far=parseFloat(e),this.inst.updateProjectionMatrix()},fov:function(e){this.inst.fov=parseFloat(e),this.inst.updateProjectionMatrix()}}},e.VglPlaneGeometry={mixins:[$],props:{/** Width along the X axis. */width:{type:M,default:1},/** Height along the Y axis. */height:{type:M,default:1},/** Number of segments along the X axis. */widthSegments:{type:M,default:1},/** Number of segments along the Y axis. */heightSegments:{type:M,default:1}},computed:{inst:function(){return new t.PlaneBufferGeometry(parseFloat(this.width),parseFloat(this.height),parseInt(this.widthSegments,10),parseInt(this.heightSegments,10))}}},e.VglPointLight={mixins:[F],props:{/**
       * The distance from the light where the intensity is 0.
       * When set to 0, then the light never stops.
       */distance:{type:M,default:0},/**
       * The amount the light dims along the distance of the light.
       * For physically correct lighting, set this to 2.
       */decay:{type:M,default:1}},computed:{inst:function(){return new t.PointLight}},watch:{inst:{handler:function(e){Object.assign(e,{distance:parseFloat(this.distance),decay:parseFloat(this.decay)})},immediate:!0},distance:function(e){this.inst.distance=parseFloat(e)},decay:function(e){this.inst.decay=parseFloat(e)}}},e.VglPoints={mixins:[W],props:{/** Name of the geometry, defining the object's structure. */geometry:L,/** Name of the material, defining the object's appearance. */material:L},computed:{inst:function(){return new t.Points}}},e.VglPointsMaterial={mixins:[O],props:{/** CSS style color of the material. */color:{type:L,default:"#fff"},/** The size of the points. */size:{type:M,default:1},/** Specify whether points' size will get smaller with the distance. */disableSizeAttenuation:C},computed:{inst:function(){return new t.PointsMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{size:parseFloat(this.size),sizeAttenuation:!this.disableSizeAttenuation}),e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)},size:function(e){this.inst.size=parseFloat(e)},disableSizeAttenuation:function(e){this.inst.sizeAttenuation=!e}}},e.VglPolarGridHelper={mixins:[P],props:{/** The radius of the polar grid. This can be any positive number. */radius:{type:M,default:10},/** The number of radial lines. This can be any positive integer. */radials:{type:M,default:16},/** The number of circles. This can be any positive integer. */circles:{type:M,default:8},/**
       * The number of line segments used for each circle.
       * This can be any positive integer that is 3 or greater.
       */divisions:{type:M,default:64},/** The first color used for grid elements. */color1:{type:L,default:"#444444"},/** The second color used for grid elements. */color2:{type:L,default:"#888888"}},computed:{inst:function(){return new t.PolarGridHelper(parseFloat(this.radius),parseInt(this.radials,10),parseInt(this.circles,10),parseInt(this.divisions,10),this.color1,this.color2)}}},e.VglRectAreaLight={mixins:[F],props:{/** Width of the light. */width:{type:M,default:10},/** Height of the light. */height:{type:M,default:10}},computed:{inst:function(){return new t.RectAreaLight}},watch:{inst:{handler:function(e){Object.assign(e,{width:parseFloat(this.width),height:parseFloat(this.height)})},immediate:!0},width:function(e){this.inst.width=parseFloat(e)},height:function(e){this.inst.height=parseFloat(e)}}},e.VglRectAreaLightHelper={mixins:[P],props:{/** If this is not the set the helper will take the color of the light. */color:{type:L},/** Name of the RectAreaLight being visualized. */light:{type:L,required:!0}},methods:{setHelper:function(){var e=this.vglNamespace.object3ds[this.light];if(this.inst.children.length){var i=n(this.inst.children,1),a=i[0];if(a.light===e)return a.color=this.color,void a.update();this.inst.remove(a)}this.inst.add(new t.RectAreaLightHelper(e,this.color))}},created:function(){this.vglNamespace.beforeRender.push(this.setHelper)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setHelper;e.splice(e.indexOf(t),1)}},e.VglRenderer={mixins:[N],props:{/** Shader precision. Can be "highp", "mediump" or "lowp". */precision:L,/** Whether the canvas contains an alpha (transparency) buffer or not. */alpha:C,/** Whether the renderer will assume that colors have premultiplied alpha. */disablePremultipliedAlpha:C,/** Whether to perform antialiasing. */antialias:C,/** Whether the drawing buffer has a stencil buffer of at least 8 bits. */disableStencil:C,/**
       * A hint to the user agent indicating what configuration of GPU is suitable
       * for this WebGL context. Can be "high-performance", "low-power" or "default".
       */powerPreference:L,/** Whether to preserve the buffers until manually cleared or overwritten. */preserveDrawingBuffer:C,/** Whether the drawing buffer has a depth buffer of at least 16 bits. */disableDepth:C,/** Whether to use a logarithmic depth buffer. */logarithmicDepthBuffer:C,/** Name of the using camera. */camera:L,/** Name of the target scene. */scene:L,/** If set, use shadow maps in the scene. */shadowMapEnabled:C},computed:{inst:function e(){var e=new t.WebGLRenderer({precision:this.precision,alpha:this.alpha,premultipliedAlpha:!this.disablePremultipliedAlpha,antialias:this.antialias,stencil:!this.disableStencil,preserveDrawingBuffer:this.preserveDrawingBuffer,depth:!this.disableDepth,logarithmicDepthBuffer:this.logarithmicDepthBuffer,powerPreference:this.powerPreference});return e.shadowMap.enabled=this.shadowMapEnabled,e},cameraInst:function(){if(this.camera!==void 0)return this.vglNamespace.cameras[this.camera];var e;// eslint-disable-next-line guard-for-in, no-restricted-syntax
for(var t in this.vglNamespace.cameras){if(e)throw new ReferenceError("Cannot identify the camera. camera prop must be set when multiple cameras are defined.");e=this.vglNamespace.cameras[t]}return e},sceneInst:function(){if(this.scene!==void 0)return this.vglNamespace.scenes[this.scene];var e;// eslint-disable-next-line guard-for-in, no-restricted-syntax
for(var t in this.vglNamespace.scenes){if(e)throw new ReferenceError("Cannot identify the scene. scene prop must be set when multiple scenes are defined.");e=this.vglNamespace.scenes[t]}return e}},methods:{render:function(){var e=this.inst,t=this.cameraInst,i=this.sceneInst;if(t&&i){if(t.isPerspectiveCamera){var a=this.$el.clientWidth/this.$el.clientHeight;t.aspect!==a&&(t.aspect=a,t.updateProjectionMatrix())}else if(t.isOrthographicCamera){var r=this.$el.clientWidth/2,n=this.$el.clientHeight/2;(t.right!==r||t.top!==n)&&(t.left=-r,t.right=r,t.top=n,t.bottom=-n,t.updateProjectionMatrix())}else throw new TypeError("Unknown camera type.");e.render(i,t)}}},watch:{inst:function(e,t){this.$el&&(e.setSize(this.$el.clientWidth,this.$el.clientHeight),this.$el.replaceChild(e.domElement,t.domElement),this.vglNamespace.update()),t.dispose()}},created:function(){this.vglNamespace.renderers.push(this)},mounted:function(){this.inst.setSize(this.$el.clientWidth,this.$el.clientHeight),this.$el.appendChild(this.inst.domElement),this.vglNamespace.update()},beforeDestroy:function(){this.vglNamespace.renderers.splice(this.vglNamespace.renderers.indexOf(this),1),this.inst.dispose()},render:function(e){var t=this;return e("div",[e("iframe",{style:{visibility:"hidden",width:"100%",height:"100%",marginRight:"-100%",border:"none"},on:{load:function(e){e.target.contentWindow.addEventListener("resize",function(){t.inst.setSize(t.$el.clientWidth,t.$el.clientHeight),t.vglNamespace.update()},!1)}}},this.$slots.default)])}},e.VglRingGeometry={mixins:[$],props:{/** Inner radius of the ring. */innerRadius:{type:M,default:.5},/** Outer radius of the ring. */outerRadius:{type:M,default:1},/** Number of segments along to the tangential direction. */thetaSegments:{type:M,default:8},/** Number of segments along to the radial direction. */phiSegments:{type:M,default:1},/** The starting angle. */thetaStart:{type:M,default:0},/** The central angle. */thetaLength:{type:M,default:2*w}},computed:{inst:function(){return new t.RingBufferGeometry(parseFloat(this.innerRadius),parseFloat(this.outerRadius),parseInt(this.thetaSegments,10),parseInt(this.phiSegments,10),parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},e.VglScene={mixins:[P],props:{/** the color, near and far parameters of the scene's fog */fog:{type:z},/**
       * Expecting to accept a string representing a color.
       * Will be overwrited by backgroundTexture prop if both props are set
      */backgroundColor:L,/** Expecting to accept a string representing a texture name. */backgroundTexture:L},computed:{inst:function(){return new t.Scene}},methods:{setBackgroundTexture:function(){var e=this.vglNamespace.textures,t=this.inst,i=this.backgroundTexture;i in e&&(t.background=e[i])}},created:function(){var e=this.vglNamespace.beforeRender,t=this.setBackgroundTexture;e.unshift(t)},watch:{inst:{handler:function(e){this.vglNamespace.scenes[this.name]=e,this.fog&&(this.inst.fog=S(this.fog)),this.backgroundColor&&(this.inst.background=x(this.backgroundColor)),this.backgroundTexture&&(this.inst.background=this.vglNamespace.textures[this.backgroundTexture]||null)},immediate:!0},name:function(e,t){var i=this.vglNamespace.scenes,a=this.inst;i[t]===a&&delete i[t],i[e]=a},fog:function(e){this.inst.fog=S(e)},backgroundColor:function(e){this.inst.background=x(e)},backgroundTexture:function(e){this.inst.background=this.vglNamespace.textures[e]||null}},beforeDestroy:function(){var e=this.vglNamespace,t=e.scenes,i=e.beforeRender,a=this.inst,r=this.setBackgroundTexture;t[this.name]===a&&delete t[this.name],i.splice(i.indexOf(r),1)}},e.VglShaderMaterial=re,e.VglShadowMaterial={mixins:[O],computed:{inst:function(){return new t.ShadowMaterial}}},e.VglSphereGeometry={mixins:[$],props:{/** Sphere radius. */radius:{type:M,default:1},/** Number of horizontal segments. */widthSegments:{type:M,default:8},/** Number of vertical segments. */heightSegments:{type:M,default:6},/** Specify horizontal starting angle. */phiStart:{type:M,default:0},/** Specify horizontal sweep angle size. */phiLength:{type:M,default:2*w},/** Specify vertical starting angle. */thetaStart:{type:M,default:0},/** Specify vertical sweep angle size. */thetaLength:{type:M,default:w}},computed:{inst:function(){return new t.SphereBufferGeometry(parseFloat(this.radius),parseInt(this.widthSegments,10),parseInt(this.heightSegments,10),parseFloat(this.phiStart),parseFloat(this.phiLength),parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},e.VglSpotLight={mixins:[F],props:{/**
       * The distance from the light where the intensity is 0.
       * When set to 0, then the light never stops.
       */distance:{type:M,default:0},/**
       * The amount the light dims along the distance of the light.
       * For physically correct lighting, set this to 2.
       */decay:{type:M,default:1},/**
       * Maximum extent of the spotlight, in radians, from its direction.
       * Should be no more than Math.PI/2.
       */angle:{type:M,default:w/3},/**
       * Percent of the spotlight cone that is attenuated due to penumbra.
       * Takes values between zero and 1.
       */penumbra:{type:M,default:0},/** The spotlight's pointing position. */target:V},computed:{inst:function(){return new t.SpotLight}},beforeDestroy:function(){this.inst.target.parent&&this.inst.target.parent.remove(this.inst.target)},watch:{inst:{handler:function(e){Object.assign(e,{distance:parseFloat(this.distance),decay:parseFloat(this.decay),angle:parseFloat(this.angle),penumbra:parseFloat(this.penumbra)}),this.target&&e.target.position.copy(g(this.target)),this.vglObject3d.inst&&this.vglObject3d.inst.add(e.target)},immediate:!0},"vglObject3d.inst":function(e){e.add(this.inst.target)},distance:function(e){this.inst.distance=parseFloat(e)},decay:function(e){this.inst.decay=parseFloat(e)},angle:function(e){this.inst.angle=parseFloat(e)},penumbra:function(e){this.inst.penumbra=parseFloat(e)},target:function(e){this.inst.target.position.copy(g(e))}}},e.VglSpotLightHelper={mixins:[P],props:{/** If this is not the set the helper will take the color of the light. */color:{type:L},/** Name of the spot light being visualized. */light:L},methods:{setHelper:function(){if(this.inst.children.length){var e=n(this.inst.children,1),i=e[0];i.light===this.vglNamespace.object3ds[this.light]?(i.color=this.color,i.update()):(this.inst.remove(i),i.dispose(),this.inst.add(new t.SpotLightHelper(this.vglNamespace.object3ds[this.light],this.color)))}else this.inst.add(new t.SpotLightHelper(this.vglNamespace.object3ds[this.light],this.color))}},created:function(){this.vglNamespace.beforeRender.push(this.setHelper)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setHelper,i=this.inst.children;e.splice(e.indexOf(t),1),i.length&&i[0].dispose()}},e.VglSprite={mixins:[U],props:{/** Name of the material, defining the object's appearance. */material:L},computed:{inst:function(){return new t.Sprite}}},e.VglSpriteMaterial={mixins:[_],props:{/** CSS style color of the material. */color:{type:L,default:"#fff"},/** The texture map of the material. */map:L},computed:{inst:function(){return new t.SpriteMaterial}},watch:{inst:{handler:function(e){e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)}}},e.VglTetrahedronGeometry={mixins:[$],props:{/** Radius of the tetrahedron. */radius:{type:M,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a tetrahedron. */detail:{type:M,default:0}},computed:{inst:function(){return new t.TetrahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},e.VglTextGeometry={mixins:[te],props:{/** The text that needs to be shown. */text:{type:L,default:""},/** The path or URL to the facetype json file. This can also be a Data URI. */font:L,/** Size of the text. */size:{type:M,default:100},/** Thickness to extrude text. */height:{type:M,default:50},/** Number of points on the curves. */curveSegments:{type:M,default:12},/** Turn on bevel. */bevelEnabled:C,/** How deep into text bevel goes. */bevelThickness:{type:M,default:10},/** How far from text outline is bevel. */bevelSize:{type:M,default:8},/** Number of bevel segments. */bevelSegments:{type:M,default:3}},data:function(){return{f:void 0}},computed:{inst:function(){return this.f===void 0?new t.BufferGeometry:new t.TextBufferGeometry(this.text,{font:ie[this.f],size:parseFloat(this.size),height:parseFloat(this.height),curveSegments:parseInt(this.curveSegments,10),bevelEnabled:this.bevelEnabled,bevelThickness:parseFloat(this.bevelThickness),bevelSize:parseFloat(this.bevelSize),bevelSegments:parseInt(this.bevelSegments,10)})}},watch:{font:{handler:function(e){var i=this;ie[e]?ie[e].isFont?this.f=e:ie[e].push(function(){e===i.font&&(i.f=e)}):(ie[e]=[function(){e===i.font&&(i.f=e),i.vglNamespace.update()}],new t.FontLoader().load(e,function(t){var i=ie[e];ie[e]=t,i.forEach(function(e){e()})}))},immediate:!0}}},e.VglTexture={inject:["vglNamespace"],props:{/** The path or URL to the file. This can also be a Data URI. */src:L,name:L,mapping:{type:L,default:"uv"},wrapS:{type:L,default:"clamp-to-edge"},wrapT:{type:L,default:"clamp-to-edge"},magFilter:{type:L,default:"linear"},minFilter:{type:L,default:"linear-mip-map-linear"},anisotropy:{type:M,default:1},format:L,type:{type:L,default:"unsigned-byte"},offset:G,repeat:G,rotation:{type:M,default:0},center:G,premultiplyAlpha:C,unpackAlignment:{type:M,default:4},encoding:{type:L,default:"linear"}},computed:{inst:function(){var e=this;return new t.TextureLoader().load(this.src,function(t){e.format&&Object.assign(t,{format:Y[e.format]}),e.vglNamespace.update()})}},watch:{inst:{handler:function(e){this.vglNamespace.textures[this.name]=e,Object.assign(e,{mapping:K[this.mapping],wrapS:J[this.wrapS],wrapT:J[this.wrapT],magFilter:X[this.magFilter],minFilter:X[this.minFilter],anisotropy:parseInt(this.anisotropy,10),type:Z[this.type],rotation:parseFloat(this.rotation),premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:parseInt(this.unpackAlignment,10),encoding:ee[this.encoding]}),this.offset&&e.offset.copy(h(this.offset)),this.repeat&&e.repeat.copy(h(this.repeat)),this.center&&e.center.copy(h(this.center))},immediate:!0},name:function(e,t){var i=this.vglNamespace.textures,a=this.inst;i[t]===a&&delete i[t],i[e]=a},mapping:function(e){this.inst.mapping=K[e]},wrapS:function(e){this.inst.wrapS=J[e]},wrapT:function(e){this.inst.wrapT=J[e]},magFilter:function(e){this.inst.magFilter=X[e]},minFilter:function(e){this.inst.minFilter=X[e]},anisotropy:function(e){this.inst.anisotropy=parseInt(e,10)},format:function(e){this.inst.format=Y[e]},type:function(e){this.inst.type=Z[e]},offset:function(e){this.inst.offset.copy(h(e))},repeat:function(e){this.inst.repeat.copy(h(e))},rotation:function(e){this.inst.rotation=parseFloat(e)},center:function(e){this.inst.center.copy(h(e))},premultiplyAlpha:function(e){this.inst.premultiplyAlpha=e},unpackAlignment:function(e){this.inst.unpackAlignment=parseInt(e,10)},encoding:function(e){this.inst.encoding=ee[e]}},beforeDestroy:function(){var e=this.vglNamespace.textures,t=this.inst,i=this.name;e[i]===t&&delete e[i]},beforeUpdate:function(){this.inst.needsUpdate=!0,this.vglNamespace.update()},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},e.VglTorusGeometry={mixins:[$],props:{/** Radius of the torus. */radius:{type:M,default:1},/** Diamiter of the tube. */tube:{type:M,default:.4},/** Number of segments of the tube's section. */radialSegments:{type:M,default:8},/** Number of segments along to the tube length direction. */tubularSegments:{type:M,default:6},/** The central angle. */arc:{type:M,default:2*w}},computed:{inst:function(){return new t.TorusBufferGeometry(parseFloat(this.radius),parseFloat(this.tube),parseInt(this.radialSegments,10),parseInt(this.tubularSegments,10),parseFloat(this.arc))}}},e.VglTorusKnotGeometry={mixins:[$],props:{/** Radius of the torus. */radius:{type:M,default:1},/** Diamiter of the tube. */tube:{type:M,default:.4},/** Number of segments of the tube's section. */radialSegments:{type:M,default:8},/** Number of segments along to the tube length direction. */tubularSegments:{type:M,default:64},/**
       * This value determines how many times the geometry winds
       * around its axis of rotational symmetry.
       */p:{type:M,default:2},/**
       * This value determines how many times the geometry winds
       * around a circle in the interior of the torus.
       */q:{type:M,default:3}},computed:{inst:function(){return new t.TorusKnotBufferGeometry(parseFloat(this.radius),parseFloat(this.tube),parseInt(this.tubularSegments,10),parseInt(this.radialSegments,10),parseInt(this.p,10),parseInt(this.q,10))}}},Object.defineProperty(e,"__esModule",{value:!0})});
